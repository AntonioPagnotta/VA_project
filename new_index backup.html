<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Italian Demographics Dashboard</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
      html, body { margin: 0; height: 100%; font-family: 'Segoe UI', sans-serif; background-color: #f4f4f9; }
      body { display: flex; flex-direction: column; height: 100vh; overflow: hidden; }

      #page-title {
        background-color: #2c3e50; color: white; padding: 15px 24px;
        font-size: 22px; font-weight: 600; display: flex;
        justify-content: space-between; align-items: center;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 10;
        flex-shrink: 0;
      }

      #status-indicator { font-size: 12px; padding: 4px 8px; border-radius: 4px; background: #e74c3c; margin-left: 15px; }

      #main-container { display: flex; flex: 1; overflow: hidden; position: relative; }

      #map-section {
        flex: 1;
        position: relative;
        border-right: 1px solid #ddd;
        min-width: 0;
        display: flex;
        flex-direction: column;
      }

      #map-container {
        flex: 6;
        position: relative;
        width: 100%;
        min-height: 0;
      }

      #map { width: 100%; height: 100%; background: #e0e0e0; }

      #pca-section {
        flex: 4;
        border-top: 1px solid #ccc;
        background: white;
        padding: 10px;
        display: flex;
        flex-direction: column;
        min-height: 0;
      }

      .map-overlay {
        position: absolute; bottom: 20px; left: 20px;
        background: rgba(255, 255, 255, 0.95); padding: 15px;
        border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        z-index: 1000; width: 280px;
      }
      .control-group { margin-bottom: 10px; }
      .control-group label { display: block; font-size: 11px; color: #555; margin-bottom: 5px; font-weight: bold; }
      select { width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; background: white; font-size: 12px; }
      .slider-container { display: flex; align-items: center; gap: 10px; }
      input[type=range] { flex: 1; }
      #play-btn {
        width: 25px; height: 25px; border-radius: 50%; border: none; background: #27ae60; color: white; cursor: pointer;
        display: flex; align-items: center; justify-content: center;
        transition: background 0.2s; font-size: 10px;
      }
      #play-btn:hover { background: #219150; }

      /* Legend Styles */
      .legend {
        background: rgba(255, 255, 255, 0.9);
        padding: 8px;
        border-radius: 5px;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
        line-height: 16px;
        color: #555;
        width: 120px;
      }
      .legend-title { font-weight: bold; margin-bottom: 5px; font-size: 11px; text-transform: uppercase; }

      .legend-gradient {
        height: 10px;
        width: 100%;
        margin-bottom: 5px;
        border-radius: 2px;
        border: 1px solid #bbb;
        background: linear-gradient(to right,
            #fcffa4 0%, #dd513a 33%, #932667 66%, #120d31 100%
        );
      }
      .legend-labels { display: flex; justify-content: space-between; font-size: 10px; color: #333; }

      #sidebar-wrapper {
        /* WIDENED SIDEBAR TO 950px */
        width: 950px;
        background: #f8f9fa; display: flex; flex-direction: column;
        position: relative; overflow: hidden; flex-shrink: 0; border-left: 1px solid #ddd;
        box-shadow: -2px 0 5px rgba(0,0,0,0.05);
      }

      .sidebar-panel {
        position: absolute; top: 0; left: 0; bottom: 0; right: 0; width: 100%; height: 100%;
        padding: 20px; box-sizing: border-box; overflow-y: auto; background: white;
        display: flex; flex-direction: column;
      }

      .info-box { background: #e8f8f5; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #16a085; }
      .info-box h2 { margin: 0 0 5px 0; font-size: 18px; color: #2c3e50; }
      .info-box .stat { font-size: 24px; font-weight: bold; color: #16a085; }
      .info-box .sub-stat { font-size: 12px; color: #7f8c8d; }

      .chart-container { position: relative; height: 350px; width: 100%; margin-bottom: 25px; flex-shrink: 0; }
      .heatmap-container { position: relative; height: 300px; width: 100%; margin-bottom: 25px; flex-shrink: 0; overflow:hidden; }

      .pca-header { font-size: 12px; font-weight: bold; text-transform: uppercase; color: #777; margin-bottom: 5px; display: flex; justify-content: space-between; }
      .pca-wrapper { flex: 1; position: relative; width: 100%; min-height: 0; }

      .section-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #eee; padding-bottom: 5px; margin-top: 10px; margin-bottom: 10px; }
      .section-header h3 { margin: 0; font-size: 14px; text-transform: uppercase; color: #888; display:flex; align-items:center; gap:10px; }

      .config-btn { background: none; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 12px; color: #555; padding: 2px 8px; margin-left:5px; }
      .config-btn:hover { background: #eee; }

      .toggle-group { display: flex; background: #eee; border-radius: 4px; padding: 2px; }
      .toggle-btn { border: none; background: none; padding: 4px 10px; font-size: 11px; cursor: pointer; border-radius: 3px; color: #666; font-weight: 600; }
      .toggle-btn.active { background: white; color: #2c3e50; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }

      .comparison-controls { display: flex; gap: 5px; margin-bottom: 10px; }
      .comparison-controls select { font-size: 11px; padding: 4px; }

      .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; justify-content: center; align-items: center; }
      .modal.open { display: flex; }
      .modal-content { background: white; padding: 20px; border-radius: 8px; width: 400px; max-height: 80vh; display: flex; flex-direction: column; }
      .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;}
      .checkbox-list { overflow-y: auto; flex: 1; margin: 10px 0; border: 1px solid #eee; padding: 10px; background: #fcfcfc; border-radius: 4px; }
      .checkbox-item { display: flex; align-items: center; padding: 5px; border-bottom: 1px solid #f0f0f0; }
      .checkbox-item input { margin-right: 10px; }
      .modal-actions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px; }
      .counter-badge { font-size: 12px; background: #eee; padding: 2px 6px; border-radius: 10px; color: #555; }
    </style>
  </head>
  <body>

    <div id="page-title">
      <div style="display:flex; align-items:center;">
        <span style="margin-right: 15px;">üáÆüáπ Italian Demographics Dashboard</span>
      </div>
      <div style="display:flex; align-items:center;">
        <div id="status-indicator">Connecting...</div>
      </div>
    </div>

    <div id="main-container">

      <div id="map-section">
        <div id="map-container">
            <div id="map"></div>
            <div class="map-overlay">
            <div class="control-group"><label>INDICATOR</label><select id="indicator-select"><option>Loading...</option></select></div>
            <div class="control-group">
                <label>YEAR: <span id="year-display">2002</span></label>
                <div class="slider-container"><button id="play-btn">‚ñ∂</button><input type="range" id="year-slider" min="2002" max="2035" value="2002" step="1"></div>
            </div>
            <button id="reset-btn" style="width:100%; padding:8px; margin-top:10px; cursor:pointer;">Reset View</button>
            </div>
        </div>

        <div id="pca-section">
            <div class="pca-header">
                <span>Multi-Indicator Clustering (PCA)</span>
                <span style="font-size:10px; font-weight:normal; color:#999">K-Means (k=3) on visible data</span>
            </div>
            <div class="pca-wrapper">
                <canvas id="pcaChart"></canvas>
            </div>
        </div>

      </div>

      <div id="sidebar-wrapper">
        <div id="sidebar-combined" class="sidebar-panel">
          <div class="info-box combined-box">
            <h2 id="region-name-combined">Italy (National)</h2>
            <div class="stat" id="current-value-combined">--</div>
            <div class="sub-stat" id="current-indicator-label-combined">Demographic Indicators</div>
          </div>

          <div class="section-header"><h3>Regional Leaderboard (<span class="dynamic-year">2002</span>)</h3></div>
          <div class="chart-container"><canvas id="leaderboardChartCombined"></canvas></div>

          <div class="section-header"><h3>Full Timeline Analysis</h3></div>
          <div class="chart-container"><canvas id="disparityChartCombined"></canvas></div>

            <div class="section-header">
              <h3>Multivariate Profile</h3>
              <div class="toggle-group">
                  <button class="toggle-btn active" id="view-radar">Radar</button>
                  <button class="toggle-btn" id="view-parallel">Parallel</button>
              </div>
              <button id="config-radar-btn" class="config-btn">‚öôÔ∏è Configure</button>
          </div>
          <div class="chart-container" id="profile-chart-container">
              <canvas id="radarChartCombined" style="display:block;"></canvas>
              <canvas id="parallelCanvas" style="display:none;"></canvas>
          </div>

          <div class="section-header"><h3>Indicator Heatmap (Timeline)</h3></div>
          <div class="heatmap-container">
             <canvas id="heatmapCanvas"></canvas>
             <div id="heatmap-loader" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(255,255,255,0.8); z-index:10; justify-content:center; align-items:center; color:#555;">Loading Matrix...</div>
          </div>

          <div class="section-header"><h3>Combined Comparison</h3></div>
          <div class="comparison-controls"><select id="comp-select-1-combined"></select><select id="comp-select-2-combined"></select></div>
          <div class="chart-container"><canvas id="comparisonChartCombined"></canvas></div>

          <div class="section-header"><h3>Yearly Correlation</h3></div>
          <div class="chart-container"><canvas id="scatterComparisonChart"></canvas></div>
        </div>
      </div>
    </div>

    <div id="radar-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
            <h4 style="margin:0">Select Multivariate Indicators</h4>
            <span id="selection-counter" class="counter-badge">0/12</span>
        </div>
        <div class="checkbox-list" id="radar-checkbox-container"></div>
        <div class="modal-actions"><button id="modal-cancel">Cancel</button><button id="modal-apply" style="background:#27ae60; color:white; border:none; padding:8px 16px; border-radius:4px; cursor:pointer;">Apply Changes</button></div>
      </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
      const SERVER_BASE = "http://127.0.0.1:5000";

      let viewContext = { combined: { indicators: [], years: {min:2002, max:2035}, currentYear: 2002, activeIndicator: '', activeLabel: '', profileMode: 'radar' } };
      let dataStore = { combined: { trend: [], radar: [], comp1: [], comp2: [], heatmap: {} } };
      let currentState = { selectedRegion: null, radarCodes: [] };
      let playInterval = null;
      const scope = 'combined';

      function arraysEqual(a, b) {
          if (a === b) return true;
          if (a == null || b == null) return false;
          if (a.length !== b.length) return false;
          for (var i = 0; i < a.length; ++i) { if (Math.abs(a[i] - b[i]) > 0.0001) return false; }
          return true;
      }

      const map = L.map('map', {
          minZoom: 5, maxBounds: [[35.0, 6.0], [48.0, 19.0]], maxBoundsViscosity: 1.0, zoomControl: false
      }).setView([41.8719, 12.5674], 5);
      L.control.zoom({ position: 'topright' }).addTo(map);
      L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap', subdomains: 'abcd', maxZoom: 19 }).addTo(map);
      let geoJsonLayer, legendControl;

      const charts = {};

      function initCharts(suffix) {
        charts[`disparity${suffix}`] = new Chart(document.getElementById(`disparityChart${suffix}`), {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: { responsive:true, maintainAspectRatio:false, scales: { x:{grid:{display:false}}, y:{beginAtZero:true}} }
        });

        charts[`comparison${suffix}`] = new Chart(document.getElementById(`comparisonChart${suffix}`), {
            type: 'line',
            data: { labels: [], datasets: [{ label: 'Ind 1', data: [], borderColor: '#9b59b6', yAxisID: 'y', tension:0.1 }, { label: 'Ind 2', data: [], borderColor: '#2ecc71', yAxisID: 'y1', tension:0.1 }] },
            options: { responsive:true, maintainAspectRatio:false, scales: { y:{position:'left'}, y1:{position:'right', grid:{drawOnChartArea:false}} } }
        });

        charts[`scatterComparison`] = new Chart(document.getElementById(`scatterComparisonChart`), {
            type: 'scatter',
            data: { datasets: [{ label: 'Region Data', data: [], backgroundColor: '#8e44ad' }] },
            options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: {display:true} }, y: { title: {display:true} } } }
        });

        charts[`radar${suffix}`] = new Chart(document.getElementById(`radarChart${suffix}`), {
            type: 'radar',
            data: { labels: [], datasets: [] },
            options: { responsive:true, maintainAspectRatio:false, scales: { r: { min:0, ticks:{display:false} } } }
        });

        charts[`leaderboard${suffix}`] = new Chart(document.getElementById(`leaderboardChart${suffix}`), {
            type: 'bar',
            data: { labels: [], datasets: [{ label: 'Value', data: [], backgroundColor: '#95a5a6' }] },
            options: {
                responsive:true,
                maintainAspectRatio:false,
                plugins: { legend: {display:false} },
                scales: {
                    x: { ticks: { autoSkip: false, maxRotation: 90, minRotation: 45 } }
                },
                onClick: (e, el) => { if(el.length) selectRegion(charts[`leaderboard${suffix}`].data.labels[el[0].index]); }
            }
        });

        charts[`pca`] = new Chart(document.getElementById(`pcaChart`), {
            type: 'scatter',
            data: { datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: true, position: 'bottom', labels: { boxWidth: 10, padding: 10, font: {size: 10} } },
                    tooltip: {
                        callbacks: { label: function(ctx) { return ctx.raw.region; } }
                    }
                },
                scales: {
                    x: { display: true, title: {display:true, text:'Principal Component 1'} },
                    y: { display: true, title: {display:true, text:'Principal Component 2'} }
                }
            }
        });
      }

      initCharts('Combined');

      async function init() {
        await initMap();
        await fetchContext(scope, -1);
        fetchTrendData(scope, -1);
        fetchRadarData(scope, -1);
        fetchComparisonData(scope, -1);
        fetchHeatmapData(scope, -1);
        updateSharedControls(scope);
        document.getElementById('status-indicator').innerText = "Connected";
        document.getElementById('status-indicator').style.background = "#27ae60";
      }

      async function fetchContext(scope, predVal) {
          try {
              const res = await fetch(`${SERVER_BASE}/indicators?pred=${predVal}`);
              const json = await res.json();
              if(json.status === 'success') {
                  viewContext[scope].indicators = json.indicators;
                  viewContext[scope].years = json.years;
                  if(json.indicators.length > 0) {
                      viewContext[scope].activeIndicator = json.indicators[0].code;
                      viewContext[scope].activeLabel = json.indicators[0].label;
                      const html = json.indicators.map(i => `<option value="${i.code}">${i.label}</option>`).join('');
                      const el1 = document.getElementById(`comp-select-1-combined`);
                      const el2 = document.getElementById(`comp-select-2-combined`);
                      if(el1 && el2) { el1.innerHTML = html; el2.innerHTML = html; el2.selectedIndex = 1; }
                  }
                  currentState.radarCodes = json.indicators.slice(0,6).map(i=>i.code);
              }
          } catch(e) { console.error("Context Error", e); }
      }

      async function fetchTrendData(scope, predVal) {
        const ind = viewContext[scope].activeIndicator;
        if(!ind) return;
        try {
          const url = new URL(`${SERVER_BASE}/query`);
          url.searchParams.append('indicator', ind);
          url.searchParams.append('pred', predVal);
          const res = await fetch(url);
          const json = await res.json();
          if (json.status === 'success') {
            dataStore[scope].trend = json.data;
            updateTimeBounds(scope);
            updateDisparityChart(scope);
            updateUI(scope);
          }
        } catch (e) { console.error(e); }
      }

      async function fetchRadarData(scope, predVal) {
        try {
          const url = new URL(`${SERVER_BASE}/yearly_data`);
          url.searchParams.append('year', viewContext[scope].currentYear);
          url.searchParams.append('pred', predVal);
          const res = await fetch(url);
          const json = await res.json();
          if (json.status === 'success') {
             dataStore[scope].radar = json.data;
             updateProfileCharts(scope);
             updateLeaderboardChart(scope);
             calculateAndRenderPCA(scope);
          }
        } catch(e) { console.error(e); }
      }

      async function fetchComparisonData(scope, predVal) {
         const i1 = document.getElementById(`comp-select-1-combined`).value;
         const i2 = document.getElementById(`comp-select-2-combined`).value;
         const u1 = new URL(`${SERVER_BASE}/query`); u1.searchParams.append('indicator', i1); u1.searchParams.append('pred', predVal);
         const u2 = new URL(`${SERVER_BASE}/query`); u2.searchParams.append('indicator', i2); u2.searchParams.append('pred', predVal);
         const [r1, r2] = await Promise.all([fetch(u1), fetch(u2)]);
         const j1 = await r1.json(); const j2 = await r2.json();
         if (j1.status === 'success') dataStore[scope].comp1 = j1.data;
         if (j2.status === 'success') dataStore[scope].comp2 = j2.data;
         updateComparisonChart(scope);
         updateScatterComparisonChart(scope);
      }

      async function fetchHeatmapData(scope, predVal) {
          const loader = document.getElementById('heatmap-loader');
          loader.style.display = 'flex';
          const indicators = currentState.radarCodes.length ? currentState.radarCodes : viewContext[scope].indicators.slice(0,6).map(i=>i.code);
          const promises = indicators.map(code => {
              const u = new URL(`${SERVER_BASE}/query`);
              u.searchParams.append('indicator', code);
              u.searchParams.append('pred', predVal);
              return fetch(u).then(r => r.json());
          });
          try {
              const results = await Promise.all(promises);
              dataStore[scope].heatmap = {};
              results.forEach((res, idx) => {
                  if(res.status === 'success') dataStore[scope].heatmap[indicators[idx]] = res.data;
              });
              renderHeatmap(scope);
          } catch(e) { console.error(e); }
          loader.style.display = 'none';
      }

      function renderHeatmap(scope) {
          const canvas = document.getElementById('heatmapCanvas');
          const ctx = canvas.getContext('2d');
          const container = canvas.parentElement;
          canvas.width = container.offsetWidth;
          canvas.height = container.offsetHeight;
          const w = canvas.width; const h = canvas.height;
          ctx.clearRect(0, 0, w, h);
          const indicators = Object.keys(dataStore[scope].heatmap);
          if(!indicators.length) return;
          const region = currentState.selectedRegion || null;
          const years = []; for(let y=viewContext[scope].years.min; y<=viewContext[scope].years.max; y++) years.push(y);
          const rowH = (h - 20) / indicators.length;
          const colW = (w - 40) / years.length;
          ctx.font = "10px Segoe UI"; ctx.textBaseline = "middle";

          indicators.forEach((indCode, rowIdx) => {
              const indLabel = viewContext[scope].indicators.find(i=>i.code===indCode)?.label || indCode;
              const data = dataStore[scope].heatmap[indCode];
              const allVals = data.map(d=>d.value);
              const min = Math.min(...allVals); const max = Math.max(...allVals); const rng = max - min || 1;
              ctx.fillStyle = "#333"; ctx.fillText(indLabel.substring(0, 15), 0, rowIdx * rowH + rowH/2);
              years.forEach((year, colIdx) => {
                  let val = 0;
                  if(region) {
                      const item = data.find(d => d.year === year && d.region.toLowerCase().includes(region.toLowerCase()));
                      val = item ? item.value : min;
                  } else {
                      const items = data.filter(d => d.year === year);
                      val = items.length ? items.reduce((a,b)=>a+b.value,0)/items.length : min;
                  }
                  const norm = (val - min) / rng;
                  let color = '#fcffa4';
                  if(norm > 0.75) color = '#120d31'; else if(norm > 0.5) color = '#932667'; else if(norm > 0.25) color = '#dd513a';
                  ctx.fillStyle = color;
                  const x = 90 + colIdx * colW; const y = rowIdx * rowH;
                  ctx.fillRect(x, y + 2, colW - 1, rowH - 4);
                  if(rowIdx === indicators.length - 1 && colIdx % 5 === 0) { ctx.fillStyle = "#777"; ctx.fillText(year, x, y + rowH + 8); }
                  if(year === viewContext[scope].currentYear) { ctx.strokeStyle = "#e74c3c"; ctx.lineWidth = 1; ctx.strokeRect(x, 0, colW, h); }
              });
          });
      }

      function renderParallelCoordinates(scope) {
          const canvas = document.getElementById('parallelCanvas');
          const ctx = canvas.getContext('2d');
          const container = canvas.parentElement;
          canvas.width = container.offsetWidth; canvas.height = container.offsetHeight;
          const w = canvas.width; const h = canvas.height;
          ctx.clearRect(0,0,w,h);

          const rawData = dataStore[scope].radar;
          if(!rawData || !rawData.length) return;

          const curInds = viewContext[scope].indicators.filter(i => currentState.radarCodes.includes(i.code));
          const effectiveInds = curInds.length > 0 ? curInds : viewContext[scope].indicators.slice(0,6);

          const axes = effectiveInds.map(ind => {
              const vals = rawData.filter(d => d.data_type === ind.code).map(d => d.value);
              const min = Math.min(...vals); const max = Math.max(...vals);
              return { code: ind.code, label: ind.label, min, max, range: max-min||1 };
          });

          const regionData = {};
          rawData.forEach(d => {
              if(!regionData[d.region]) regionData[d.region] = {};
              regionData[d.region][d.data_type] = d.value;
          });

          const padLeft=20, padRight=20, padTop=30, padBottom=20;
          const axisSpacing = (w - padLeft - padRight) / (axes.length - 1);

          ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1; ctx.fillStyle = '#555'; ctx.font = '10px Segoe UI'; ctx.textAlign = 'center';
          axes.forEach((ax, i) => {
              const x = padLeft + i * axisSpacing;
              ctx.beginPath(); ctx.moveTo(x, padTop); ctx.lineTo(x, h - padBottom); ctx.stroke();
              ctx.fillText(ax.label.substring(0,15), x, padTop - 10);
              ctx.fillText(ax.min.toFixed(0), x, h - padBottom + 12);
              ctx.fillText(ax.max.toFixed(0), x, padTop + 10);
          });

          function getXY(val, axisIdx) {
              const ax = axes[axisIdx];
              const norm = (val - ax.min) / ax.range;
              const x = padLeft + axisIdx * axisSpacing;
              const y = (h - padBottom) - (norm * (h - padBottom - padTop));
              return {x, y};
          }

          ctx.lineWidth = 1;
          Object.keys(regionData).forEach(reg => {
              const isSelected = currentState.selectedRegion && reg.includes(currentState.selectedRegion);
              if (isSelected) return;

              ctx.strokeStyle = 'rgba(200, 200, 200, 0.4)';
              ctx.beginPath();
              let started = false;
              axes.forEach((ax, i) => {
                  const val = regionData[reg][ax.code];
                  if(val != null) {
                      const pos = getXY(val, i);
                      if(!started) { ctx.moveTo(pos.x, pos.y); started=true; }
                      else ctx.lineTo(pos.x, pos.y);
                  }
              });
              ctx.stroke();
          });

          const avgs = {};
          axes.forEach(ax => {
              const vals = rawData.filter(d => d.data_type === ax.code).map(d => d.value);
              avgs[ax.code] = vals.reduce((a,b)=>a+b,0)/vals.length;
          });

          ctx.strokeStyle = '#e67e22'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
          ctx.beginPath();
          let s2 = false;
          axes.forEach((ax, i) => {
              const pos = getXY(avgs[ax.code], i);
              if(!s2) { ctx.moveTo(pos.x, pos.y); s2=true; } else ctx.lineTo(pos.x, pos.y);
          });
          ctx.stroke();
          ctx.setLineDash([]);

          if(currentState.selectedRegion) {
             const regName = Object.keys(regionData).find(r => r.includes(currentState.selectedRegion));
             if(regName) {
                 ctx.strokeStyle = '#16a085'; ctx.lineWidth = 3;
                 ctx.beginPath();
                 let s3 = false;
                 axes.forEach((ax, i) => {
                      const val = regionData[regName][ax.code];
                      if(val != null) {
                          const pos = getXY(val, i);
                          if(!s3) { ctx.moveTo(pos.x, pos.y); s3=true; } else ctx.lineTo(pos.x, pos.y);
                      }
                 });
                 ctx.stroke();
             }
          }
      }

      function calculateAndRenderPCA(scope) {
         const rawData = dataStore[scope].radar; if (!rawData || !rawData.length) return;
         const regionMap = {}; const indicators = [...new Set(rawData.map(d => d.data_type))];
         rawData.forEach(d => { if(!regionMap[d.region]) regionMap[d.region] = {}; regionMap[d.region][d.data_type] = d.value; });
         const matrix = []; const regionLabels = [];
         Object.keys(regionMap).forEach(reg => {
             const row = []; let complete = true;
             indicators.forEach(ind => { if (regionMap[reg][ind] == null) complete = false; else row.push(regionMap[reg][ind]); });
             if(complete) { matrix.push(row); regionLabels.push(reg); }
         });
         if(matrix.length < 3) return;
         const colCount = matrix[0].length;
         for(let j=0; j<colCount; j++) {
             const colVals = matrix.map(r => r[j]); const mean = colVals.reduce((a,b)=>a+b,0)/colVals.length;
             const std = Math.sqrt(colVals.map(x=>Math.pow(x-mean,2)).reduce((a,b)=>a+b,0)/colVals.length) || 1;
             for(let i=0; i<matrix.length; i++) matrix[i][j] = (matrix[i][j] - mean) / std;
         }
         function getFirstPrincipalComponent(X, iterations=10) {
             const n = X.length; const m = X[0].length; let w = Array(m).fill(0).map(()=>Math.random()); let mag = Math.sqrt(w.reduce((a,b)=>a+b*b,0)); w = w.map(x=>x/mag);
             for(let iter=0; iter<iterations; iter++) {
                 let t = Array(n).fill(0); for(let i=0; i<n; i++) for(let j=0; j<m; j++) t[i] += X[i][j] * w[j];
                 let w_new = Array(m).fill(0); for(let j=0; j<m; j++) for(let i=0; i<n; i++) w_new[j] += X[i][j] * t[i];
                 mag = Math.sqrt(w_new.reduce((a,b)=>a+b*b,0)); w = w_new.map(x=>x/mag);
             } return w;
         }
         const pc1_weights = getFirstPrincipalComponent(matrix);
         const scores1 = matrix.map(row => row.reduce((sum, val, idx) => sum + val * pc1_weights[idx], 0));
         const residualMatrix = matrix.map((row, rIdx) => row.map((val, cIdx) => val - scores1[rIdx] * pc1_weights[cIdx]));
         const pc2_weights = getFirstPrincipalComponent(residualMatrix);
         const scores2 = residualMatrix.map(row => row.reduce((sum, val, idx) => sum + val * pc2_weights[idx], 0));
         const projectedPoints = regionLabels.map((lbl, i) => ({ x: scores1[i], y: scores2[i], region: lbl }));
         let k = 3; let centroids = []; const indices = new Set();
         while(centroids.length < k && indices.size < projectedPoints.length) { const idx = Math.floor(Math.random() * projectedPoints.length); if(!indices.has(idx)) { indices.add(idx); centroids.push({...projectedPoints[idx]}); } }
         let assignments = new Array(projectedPoints.length).fill(0);
         for(let iter=0; iter<10; iter++) {
             projectedPoints.forEach((p, i) => { let minDist = Infinity; centroids.forEach((c, cIdx) => { const dist = Math.pow(p.x - c.x, 2) + Math.pow(p.y - c.y, 2); if(dist < minDist) { minDist = dist; assignments[i] = cIdx; } }); });
             const newCentroids = Array(k).fill(0).map(()=>({x:0, y:0, count:0}));
             projectedPoints.forEach((p, i) => { const id = assignments[i]; newCentroids[id].x += p.x; newCentroids[id].y += p.y; newCentroids[id].count++; });
             centroids = newCentroids.map(c => c.count ? {x: c.x/c.count, y: c.y/c.count} : c);
         }
         const colors = ['#e74c3c', '#3498db', '#2ecc71']; const datasets = [];
         for(let i=0; i<k; i++) {
             const clusterData = projectedPoints.filter((_, idx) => assignments[idx] === i).map(p => ({ x: p.x, y: p.y, region: p.region }));
             datasets.push({ label: `Cluster ${i+1}`, data: clusterData, backgroundColor: colors[i], pointRadius: 6, pointHoverRadius: 8 });
         }
         const chart = charts['pca']; chart.data.datasets = datasets; chart.update();
      }

      function updateProfileCharts(scope) {
          if (viewContext[scope].profileMode === 'radar') {
              document.getElementById('radarChartCombined').style.display = 'block';
              document.getElementById('parallelCanvas').style.display = 'none';
              updateRadarChart(scope);
          } else {
              document.getElementById('radarChartCombined').style.display = 'none';
              document.getElementById('parallelCanvas').style.display = 'block';
              renderParallelCoordinates(scope);
          }
      }

      function updateRadarChart(scope) {
          const chart = charts[`radarCombined`];
          const rawData = dataStore[scope].radar;
          const curInds = viewContext[scope].indicators.filter(i => currentState.radarCodes.includes(i.code));
          const effectiveInds = curInds.length > 0 ? curInds : viewContext[scope].indicators.slice(0,6);
          const labels=[], avgs=[], regs=[];
          effectiveInds.forEach(ind => {
              labels.push(ind.label.substring(0,12));
              const vals = rawData.filter(d => d.data_type === ind.code).map(d => d.value);
              if(!vals.length) { avgs.push(0); regs.push(0); return; }
              const min=Math.min(...vals), max=Math.max(...vals), rng=max-min||1;
              avgs.push((vals.reduce((a,b)=>a+b,0)/vals.length - min)/rng);
              const regVal = rawData.find(d => d.data_type === ind.code && d.region.toLowerCase().includes((currentState.selectedRegion||'').toLowerCase()))?.value;
              regs.push(regVal != null ? (regVal-min)/rng : 0);
          });
          chart.data.labels = labels;
          chart.data.datasets = [{ label: 'Avg', data: avgs, borderColor: '#e67e22', backgroundColor: '#e67e2233', borderWidth:2 }];
          if(currentState.selectedRegion) chart.data.datasets.push({ label: currentState.selectedRegion, data: regs, borderColor: '#16a085', backgroundColor: '#16a08533', borderWidth:2 });
          chart.update();
      }

      function updateTimeBounds(scope) { const data = dataStore[scope].trend; if (!data || !data.length) return; const years = data.map(d => d.year); const slider = document.getElementById('year-slider'); slider.min = Math.min(...years); slider.max = Math.max(...years); }
      function updateSharedControls(scope) { const ctx = viewContext[scope]; const select = document.getElementById('indicator-select'); select.innerHTML = ''; ctx.indicators.forEach(ind => { const opt = new Option(ind.label, ind.code); if(ind.code === ctx.activeIndicator) opt.selected = true; select.add(opt); }); document.getElementById('year-slider').value = ctx.currentYear; document.getElementById('year-display').innerText = ctx.currentYear; updateUI(scope); }

      function updateUI(scope) {
         const data = dataStore[scope].trend;
         document.getElementById(`region-name-combined`).innerText = currentState.selectedRegion || "National Average";
         document.querySelectorAll(`.dynamic-year`).forEach(el => el.innerText = viewContext[scope].currentYear);
         const val = getTrendValueForRegion(data, currentState.selectedRegion, viewContext[scope].currentYear);
         document.getElementById(`current-value-combined`).innerText = val !== null ? val : '--';
         updateMapColors(data, viewContext[scope].currentYear);
         renderHeatmap(scope);
         updateProfileCharts(scope);
      }

      function updateDisparityChart(scope) {
          const chart = charts[`disparityCombined`];
          const data = dataStore[scope].trend; if(!data.length) return;
          const years = [...new Set(data.map(d => d.year))].sort((a,b)=>a-b);
          const minD=[], maxD=[], avgD=[], regD=[];
          years.forEach(y => {
             const vals = data.filter(d => d.year === y).map(d => d.value);
             if(vals.length) { minD.push(Math.min(...vals)); maxD.push(Math.max(...vals)); avgD.push(vals.reduce((a,b)=>a+b,0)/vals.length); } else { minD.push(null); maxD.push(null); avgD.push(null); }
             regD.push(getTrendValueForRegion(data, currentState.selectedRegion, y));
          });
          const datasets = [{ label: 'Max', data: maxD, borderColor: 'transparent', backgroundColor: '#16a08533', fill: '+1', pointRadius:0, order:3 }, { label: 'Min', data: minD, borderColor: 'transparent', fill: false, pointRadius:0, order:4 }, { label: 'Avg', data: avgD, borderColor: '#e67e22', borderDash:[5,5], fill:false, pointRadius:1, order:2 }];
          if (currentState.selectedRegion) datasets.push({ label: currentState.selectedRegion, data: regD, borderColor: '#16a085', backgroundColor: '#16a085', fill: false, pointRadius:3, order:1 });
          chart.data.labels = years; chart.data.datasets = datasets; chart.update();
      }

      function updateComparisonChart(scope) {
          const chart = charts[`comparisonCombined`]; const d1 = dataStore[scope].comp1; const d2 = dataStore[scope].comp2; if(!d1.length || !d2.length) return;
          const years = [...new Set([...d1.map(d=>d.year), ...d2.map(d=>d.year)])].sort((a,b)=>a-b);
          chart.data.labels = years;
          chart.data.datasets[0].data = years.map(y => getTrendValueForRegion(d1, currentState.selectedRegion, y));
          chart.data.datasets[1].data = years.map(y => getTrendValueForRegion(d2, currentState.selectedRegion, y));
          const s1 = document.getElementById('comp-select-1-combined'); const s2 = document.getElementById('comp-select-2-combined');
          chart.data.datasets[0].label = s1.options[s1.selectedIndex]?.text; chart.data.datasets[1].label = s2.options[s2.selectedIndex]?.text; chart.update();
      }
      function updateScatterComparisonChart(scope) {
          const chart = charts['scatterComparison']; const d1 = dataStore[scope].comp1.filter(d => d.year === viewContext[scope].currentYear); const d2 = dataStore[scope].comp2.filter(d => d.year === viewContext[scope].currentYear);
          let pts = []; const regions = [...new Set(d1.map(d=>d.region))];
          regions.forEach(reg => { const v1 = d1.find(d=>d.region===reg)?.value; const v2 = d2.find(d=>d.region===reg)?.value; if(v1!=null && v2!=null) pts.push({x:v2, y:v1, region:reg}); });
          if(currentState.selectedRegion) pts = pts.filter(p => p.region.includes(currentState.selectedRegion));
          chart.data.datasets[0].data = pts; chart.update();
      }
      function updateLeaderboardChart(scope) {
          const chart = charts[`leaderboardCombined`]; const ind = viewContext[scope].activeIndicator;
          let chartData = dataStore[scope].radar.filter(d => d.data_type === ind); const uniq = new Map(); chartData.forEach(d => uniq.set(d.region, d));
          chartData = Array.from(uniq.values()).sort((a,b) => b.value - a.value);
          chart.data.labels = chartData.map(d => d.region); chart.data.datasets[0].data = chartData.map(d => d.value);
          chart.data.datasets[0].backgroundColor = chartData.map(d => (currentState.selectedRegion && d.region.includes(currentState.selectedRegion)) ? '#16a085' : '#95a5a6'); chart.update();
      }
      function getTrendValueForRegion(dataset, region, year) { if(!dataset || !dataset.length) return null; if(region) { const r = dataset.find(d => d.year == year && d.region.toLowerCase().includes(region.toLowerCase())); return r ? r.value : null; } else { const rs = dataset.filter(d => d.year == year); return rs.length ? (rs.reduce((a,b)=>a+b.value,0)/rs.length).toFixed(1) : null; } }
      function updateMapColors(dataset, year) { if(!geoJsonLayer) return; const allValues = dataset.map(d => d.value); const minGlobal = allValues.length ? Math.min(...allValues) : 0; const maxGlobal = allValues.length ? Math.max(...allValues) : 0; if(legendControl) { legendControl.getContainer().querySelector('.legend-labels').innerHTML = `<span>${minGlobal.toFixed(1)}</span><span>${maxGlobal.toFixed(1)}</span>`; } geoJsonLayer.eachLayer(layer => { const name = layer.feature.properties.reg_name; const val = getTrendValueForRegion(dataset, name, year); let col = '#ccc'; if (val != null) { const norm = (val - minGlobal) / (maxGlobal - minGlobal || 1); if (norm > 0.75) col = '#120d31'; else if (norm > 0.5) col = '#932667'; else if (norm > 0.25) col = '#dd513a'; else col = '#fcffa4'; } layer.setStyle({ fillColor: col }); layer.bindTooltip(`<strong>${name}</strong><br>Val: ${val||'N/A'}`); }); }
      async function initMap() { const res = await fetch('https://raw.githubusercontent.com/openpolis/geojson-italy/master/geojson/limits_IT_regions.geojson'); const data = await res.json(); geoJsonLayer = L.geoJson(data, { style: { fillColor:'#ccc', weight:1, opacity:1, color:'white', dashArray:'3', fillOpacity:0.7 }, onEachFeature: (f, l) => { l.on('click', () => selectRegion(f.properties.reg_name)); } }).addTo(map); legendControl = L.control({position: 'bottomright'}); legendControl.onAdd = function () { var div = L.DomUtil.create('div', 'legend'); div.innerHTML = '<div class="legend-title">Intensity</div><div class="legend-gradient"></div><div class="legend-labels"><span>Min</span><span>Max</span></div>'; return div; }; legendControl.addTo(map); }

      function selectRegion(name) {
          currentState.selectedRegion = name;
          if(geoJsonLayer) { geoJsonLayer.resetStyle(); geoJsonLayer.eachLayer(l => { if(name && l.feature.properties.reg_name.includes(name)) { l.setStyle({ weight:3, color:'#666', dashArray:'' }); l.bringToFront(); } }); }
          updateDisparityChart(scope); updateUI(scope); updateLeaderboardChart(scope); updateScatterComparisonChart(scope);
      }

      // --- EVENT LISTENERS ---
      document.getElementById('indicator-select').addEventListener('change', (e) => { const newCode = e.target.value; const ind = viewContext[scope].indicators.find(i => i.code === newCode); if(ind) { viewContext[scope].activeIndicator = newCode; fetchTrendData(scope, -1); } });
      document.getElementById('comp-select-1-combined').addEventListener('change', () => fetchComparisonData(scope, -1));
      document.getElementById('comp-select-2-combined').addEventListener('change', () => fetchComparisonData(scope, -1));
      document.getElementById('year-slider').addEventListener('input', (e) => { if(playInterval) clearInterval(playInterval); viewContext[scope].currentYear = parseInt(e.target.value); document.getElementById('year-display').innerText = viewContext[scope].currentYear; fetchRadarData(scope, -1); updateUI(scope); });
      document.getElementById('play-btn').addEventListener('click', () => { if(playInterval) { clearInterval(playInterval); playInterval = null; document.getElementById('play-btn').innerText = "‚ñ∂"; } else { document.getElementById('play-btn').innerText = "‚è∏"; playInterval = setInterval(() => { const sl = document.getElementById('year-slider'); if(parseInt(sl.value) < parseInt(sl.max)) { sl.value = parseInt(sl.value) + 1; sl.dispatchEvent(new Event('input')); } else clearInterval(playInterval); }, 1200); } });
      document.getElementById('reset-btn').addEventListener('click', () => selectRegion(null));
      document.getElementById('config-radar-btn').addEventListener('click', () => { const container = document.getElementById('radar-checkbox-container'); container.innerHTML = ''; viewContext[scope].indicators.forEach(ind => { const d = document.createElement('div'); d.className='checkbox-item'; d.innerHTML = `<input type="checkbox" value="${ind.code}" ${currentState.radarCodes.includes(ind.code)?'checked':''}> <label>${ind.label}</label>`; container.appendChild(d); }); document.getElementById('radar-modal').classList.add('open'); });
      document.getElementById('modal-cancel').addEventListener('click', () => document.getElementById('radar-modal').classList.remove('open'));
      document.getElementById('modal-apply').addEventListener('click', () => { const chk = document.getElementById('radar-checkbox-container').querySelectorAll('input:checked'); currentState.radarCodes = Array.from(chk).map(c=>c.value); fetchHeatmapData(scope, -1); updateProfileCharts(scope); document.getElementById('radar-modal').classList.remove('open'); });

      // TOGGLE HANDLERS
      document.getElementById('view-radar').addEventListener('click', () => {
          viewContext[scope].profileMode = 'radar';
          document.getElementById('view-radar').classList.add('active');
          document.getElementById('view-parallel').classList.remove('active');
          updateProfileCharts(scope);
      });
      document.getElementById('view-parallel').addEventListener('click', () => {
          viewContext[scope].profileMode = 'parallel';
          document.getElementById('view-parallel').classList.add('active');
          document.getElementById('view-radar').classList.remove('active');
          updateProfileCharts(scope);
      });

      init();
    </script>
  </body>
</html>