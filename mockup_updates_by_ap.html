<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Analytics Dashboard by Pagnotta, Sorrentini and Trionfetti</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

<style>
    :root {
        --primary-bg: #f4f6f8;
        --card-bg: #ffffff;
        --header-bg: #2c3e50;
        --text-main: #333;
        --accent: #3498db;
        --border-radius: 8px;
    }

    body {
        font-family: 'Segoe UI', sans-serif;
        margin: 0; background-color: var(--primary-bg);
        height: 100vh; display: flex; flex-direction: column; overflow: hidden;
    }

    header {
        background-color: var(--header-bg);
        color: white; padding: 0 15px; height: 40px;
        display: flex; align-items: center; justify-content: space-between;
        flex-shrink: 0;
    }

    .dashboard-container {
        display: grid;
        grid-template-columns: 40% 60%;
        gap: 8px; padding: 8px;
        height: calc(100vh - 40px);
        box-sizing: border-box;
    }

    .col { display: flex; flex-direction: column; gap: 8px; height: 100%; min-height: 0; }

    .card {
        background: var(--card-bg);
        border-radius: var(--border-radius);
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        padding: 10px;
        display: flex;
        flex-direction: column;
        min-height: 0;
        box-sizing: border-box;
        overflow: hidden;
    }

    .card-header {
        font-size: 0.7rem; font-weight: 700; color: var(--header-bg);
        border-bottom: 1px solid #eee; margin-bottom: 5px; padding-bottom: 3px;
        text-transform: uppercase;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    /* Bubble chart header controls */
    .bubble-wrapper .card-header > div {
        display: flex; gap: 6px; align-items: center; flex-wrap: wrap;
    }

    .bubble-wrapper .card-header label {
        font-size: 0.62rem; margin: 0 4px; color: #586067;
    }

    .bubble-wrapper .card-header .mini-select {
        padding: 4px 8px; font-size: 0.62rem; min-width: 70px; max-width: 140px; height: 28px; box-sizing: border-box;
    }

    /* Map legend */
    .map-legend {
        position: absolute; left: 8px; top: 8px; bottom: 8px; width: 150px;
        background: rgba(255,255,255,0.95); border-radius: 6px;
        box-shadow: 0 3px 12px rgba(0,0,0,0.12); padding: 8px 8px;
        font-size: 12px; z-index: 1000; color: #2c3e50;
        display: flex; flex-direction: column; justify-content: space-between; overflow: visible;
    }

    .map-legend .legend-title {
        font-weight: 700; font-size: 12px; margin-bottom: 6px; color: #1f2d3d;
    }

    .map-legend .legend-item {
        display: flex; gap: 8px; align-items: center; padding: 4px 0;
    }

    .map-legend .legend-swatch {
        width: 22px; height: 14px; border-radius: 3px; box-shadow: inset 0 -1px 0 rgba(0,0,0,0.1); flex-shrink: 0;
    }

    .map-legend .legend-label { flex: 1; font-size: 11px; color: #475569; }

    /* Layout Ratios */
    .map-wrapper { flex: 1; min-height: 0; }
    .cluster-wrapper { flex: 1; min-height: 0; }
    .bubble-wrapper { flex: 1; min-height: 0; overflow: hidden; }
    .stats-wrapper { flex: 1; min-height: 0; overflow: hidden; }

    .chart-container {
        flex: 1; position: relative; width: 100%; min-height: 0;
        padding: 5px 15px 15px 15px; display: flex; flex-direction: column; overflow: hidden;
    }

    .cluster-wrapper .chart-container { padding-bottom: 0; }

    .cluster-chart-area { flex: 1; position: relative; min-height: 0; }

    .temporal-controls-area {
        flex-shrink: 0; padding: 10px; background: rgba(255, 255, 255, 0.98); border-top: 1px solid #eee;
    }

    .cluster-controls { display: flex; gap: 6px; align-items: center; font-size: 0.65rem; }

    .mini-select {
        padding: 6px 12px; font-size: 0.7rem; border: 2px solid transparent; border-radius: 8px;
        background: linear-gradient(145deg, #ffffff, #f5f7fa);
        box-shadow: 0 2px 6px rgba(0,0,0,0.08), inset 0 1px 2px rgba(255,255,255,0.8);
        cursor: pointer; transition: all 0.3s ease; font-weight: 500;
    }

    .mini-select:hover {
        border-color: #667eea; box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2); transform: translateY(-1px);
    }

    .mini-select:focus {
        outline: none; border-color: #667eea;
        box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3), 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .btn-mini {
        padding: 2px 6px; font-size: 0.7rem; background: #3498db; color: white;
        border: none; border-radius: 3px; cursor: pointer; transition: all 0.2s;
    }

    .btn-mini:hover { background: #2980b9; }

    .btn-mini.active {
        background: #e74c3c; box-shadow: 0 0 0 2px rgba(231, 76, 60, 0.3); font-weight: bold;
    }

    .bubble-wrapper .chart-container { padding: 5px 10px 40px 10px; }
    .bubble-wrapper canvas { width: 100% !important; height: 100% !important; max-width: 100%; max-height: 100%; }

    .bubble-controls-overlay {
        position: absolute; bottom: 5px; left: 50px;
        background: rgba(255, 255, 255, 0.92); border-radius: 4px; padding: 4px;
        box-shadow: 0 1px 4px rgba(0,0,0,0.15); display: flex; gap: 3px; z-index: 10;
    }

    .zoom-controls { display: flex; gap: 2px; }
    .pan-controls { display: grid; grid-template-columns: repeat(3, 28px); gap: 2px; }

    .control-btn {
        width: 24px; height: 24px; padding: 0; font-size: 12px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white; border: none; border-radius: 6px; cursor: pointer;
        display: flex; align-items: center; justify-content: center; font-weight: bold;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);
    }

    .control-btn:hover { transform: translateY(-2px) scale(1.05); box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5); }
    .control-btn:active { transform: translateY(0) scale(0.98); box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3); }

    .scale-toggle {
        display: flex; align-items: center; gap: 3px; font-size: 0.65rem; padding-left: 8px; border-left: 1px solid #ddd;
    }
    .scale-toggle input[type="checkbox"] { width: 12px; height: 12px; }

    .k-display { font-size: 0.65rem; color: #7f8c8d; font-weight: normal; }

    /* Temporal controls */
    .temporal-controls { display: flex; flex-direction: column; gap: 8px; }
    .temporal-controls.active { display: flex; }

    .timeline-slider {
        width: 100%; margin: 5px 0; height: 8px; -webkit-appearance: none; appearance: none;
        background: linear-gradient(90deg, #e0e7ff 0%, #f3e7e9 100%);
        outline: none; border-radius: 10px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        transition: all 0.3s ease; opacity: 0.95;
    }
    .timeline-slider:hover { opacity: 1; box-shadow: inset 0 2px 6px rgba(0,0,0,0.15), 0 2px 8px rgba(102, 126, 234, 0.2); }

    .timeline-slider::-webkit-slider-thumb {
        -webkit-appearance: none; appearance: none; width: 20px; height: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        cursor: pointer; border-radius: 50%; border: 3px solid white;
        box-shadow: 0 3px 10px rgba(102, 126, 234, 0.5), 0 1px 3px rgba(0,0,0,0.2);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .timeline-slider::-webkit-slider-thumb:hover { transform: scale(1.2); box-shadow: 0 4px 16px rgba(102, 126, 234, 0.7), 0 2px 6px rgba(0,0,0,0.3); }
    .timeline-slider::-webkit-slider-thumb:active { transform: scale(1.1); }

    .timeline-slider::-moz-range-thumb {
        width: 20px; height: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        cursor: pointer; border-radius: 50%; border: 3px solid white;
        box-shadow: 0 3px 10px rgba(102, 126, 234, 0.5), 0 1px 3px rgba(0,0,0,0.2);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .timeline-slider::-moz-range-thumb:hover { transform: scale(1.2); box-shadow: 0 4px 16px rgba(102, 126, 234, 0.7), 0 2px 6px rgba(0,0,0,0.3); }
    .timeline-slider::-moz-range-thumb:active { transform: scale(1.1); }

    .timeline-slider.overview-mode {
        background: linear-gradient(90deg, #ffeaa7 0%, #fd79a8 100%);
        box-shadow: inset 0 2px 6px rgba(0,0,0,0.15), 0 0 20px rgba(253, 121, 168, 0.3);
    }
    .timeline-slider.overview-mode::-webkit-slider-thumb {
        width: 26px; height: 26px;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        box-shadow: 0 4px 16px rgba(245, 87, 108, 0.7), 0 2px 8px rgba(0,0,0,0.3), 0 0 0 3px rgba(255,255,255,0.9);
        animation: glow 2s infinite;
    }
    .timeline-slider.overview-mode::-moz-range-thumb {
        width: 26px; height: 26px;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        box-shadow: 0 4px 16px rgba(245, 87, 108, 0.7), 0 2px 8px rgba(0,0,0,0.3), 0 0 0 3px rgba(255,255,255,0.9);
        animation: glow 2s infinite;
    }

    @keyframes glow {
        0%, 100% { box-shadow: 0 4px 16px rgba(245, 87, 108, 0.7), 0 2px 8px rgba(0,0,0,0.3), 0 0 0 3px rgba(255,255,255,0.9); }
        50% { box-shadow: 0 4px 24px rgba(245, 87, 108, 1), 0 2px 10px rgba(0,0,0,0.4), 0 0 0 4px rgba(255,255,255,1); }
    }

    .playback-controls { display: flex; gap: 5px; align-items: center; font-size: 0.7rem; }

    .year-display {
        font-weight: 700; font-size: 0.85rem; color: white; padding: 6px 14px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 8px; min-width: 55px; text-align: center;
        box-shadow: 0 3px 10px rgba(102, 126, 234, 0.4), inset 0 1px 2px rgba(255,255,255,0.3);
        letter-spacing: 0.5px; transition: all 0.3s ease;
    }
    .year-display:hover { transform: scale(1.05); box-shadow: 0 4px 14px rgba(102, 126, 234, 0.6); }

    .loading-overlay {
        position: absolute; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(255, 255, 255, 0.9); display: none;
        align-items: center; justify-content: center; font-size: 0.75rem;
        color: #7f8c8d; z-index: 100;
    }
    .loading-overlay.active { display: flex; }

    /* ============================================
       PROFESSIONAL TABLE STYLING
       ============================================ */

    /* Container with soft shadow and rounded corners */
    .table-scroll {
        overflow: auto;
        flex-grow: 1;
        background: #ffffff;
        border-radius: 8px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        border: 1px solid #e2e8f0;
        margin-top: 8px;
        scrollbar-width: thin;
        scrollbar-color: #cbd5e1 #f1f5f9;
    }

    /* Webkit Scrollbar Styling */
    .table-scroll::-webkit-scrollbar { width: 8px; height: 8px; }
    .table-scroll::-webkit-scrollbar-track { background: #f1f5f9; border-radius: 4px; }
    .table-scroll::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 4px; border: 2px solid #f1f5f9; }
    .table-scroll::-webkit-scrollbar-thumb:hover { background-color: #94a3b8; }

    /* Main Table Layout */
    table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        font-size: 0.75rem;
        font-family: 'Segoe UI', system-ui, sans-serif;
        color: #334155;
    }

    /* Header Styling */
    th {
        background: #f8fafc; color: #475569; font-weight: 700;
        text-transform: uppercase; letter-spacing: 0.05em; font-size: 0.7rem;
        padding: 12px 10px; text-align: center;
        border-bottom: 2px solid #e2e8f0; border-right: 1px solid #f1f5f9;
        position: sticky; top: 0; z-index: 20;
        box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }

    /* First Column (Regions/Clusters) Sticky Styling */
    .col-selected-regions {
        background-color: #ffffff; font-weight: 600; color: #1e293b;
        text-align: left; width: 130px; min-width: 130px;
        border-right: 2px solid #e2e8f0;
        position: sticky; left: 0; z-index: 10;
    }

    /* Fix z-index for the top-left corner cell */
    th.col-selected-regions {
        z-index: 30; background-color: #f8fafc; border-bottom: 2px solid #e2e8f0;
    }

    /* Row Styling */
    tbody tr { transition: background-color 0.15s ease; }
    tbody tr:hover td { filter: brightness(0.97); }

    /* Cell Styling */
    td {
        padding: 8px 6px; text-align: center;
        border-bottom: 1px solid #f1f5f9; border-right: 1px solid #f8fafc;
        vertical-align: middle;
    }

    /* Value Box (The white pill with numbers) */
    .topk-value-box {
        display: inline-block;
        background: rgba(255, 255, 255, 0.92);
        color: #0f172a;
        padding: 4px 8px; border-radius: 6px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
        min-width: 42px; text-align: center;
        font-weight: 600; font-size: 0.7rem;
        border: 1px solid rgba(0,0,0,0.04);
        font-variant-numeric: tabular-nums;
    }

    /* "No Data" Styling */
    td span.no-data { color: #94a3b8; font-style: italic; font-weight: 400; }

    /* K Slider Styling */
    .k-slider-container { display: flex; align-items: center; gap: 8px; padding: 0 5px; }

    /* Manual variable selection list */
    .manual-variables-list {
        display: none; max-height: 280px; overflow-y: auto;
        border: 2px solid #e0e7ff; border-radius: 8px; padding: 12px;
        background: linear-gradient(135deg, #fafbff 0%, #f5f7fa 100%);
        width: 100%; margin-top: 8px;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
    }
    .manual-variables-list.active { display: block; }
    .manual-variables-list::-webkit-scrollbar { width: 8px; }
    .manual-variables-list::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
    .manual-variables-list::-webkit-scrollbar-thumb { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 10px; }
    .manual-variables-list::-webkit-scrollbar-thumb:hover { background: linear-gradient(135deg, #764ba2 0%, #667eea 100%); }

    .variable-checkbox-item {
        display: flex; align-items: center; gap: 6px; padding: 4px 0; font-size: 0.7rem; cursor: pointer;
    }
    .variable-checkbox-item:hover { background: #f0f0f0; border-radius: 3px; }
    .variable-checkbox-item input[type="checkbox"] { cursor: pointer; }
    .variable-checkbox-item label { cursor: pointer; flex: 1; }

    .k-slider {
        -webkit-appearance: none; appearance: none; width: 100%; height: 8px;
        border-radius: 10px; background: #e0e7ff; outline: none; transition: all 0.3s ease;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    }
    .k-slider:hover { box-shadow: inset 0 1px 4px rgba(0,0,0,0.15), 0 2px 8px rgba(102, 126, 234, 0.2); }
    .k-slider::-webkit-slider-thumb {
        -webkit-appearance: none; appearance: none; width: 18px; height: 18px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border: 3px solid #fff; border-radius: 50%; cursor: pointer;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.5);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .k-slider::-webkit-slider-thumb:hover { transform: scale(1.2); box-shadow: 0 3px 12px rgba(102, 126, 234, 0.7); }
    .k-slider::-moz-range-thumb {
        width: 18px; height: 18px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border: 3px solid #fff; border-radius: 50%; cursor: pointer;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.5);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .k-slider::-moz-range-thumb:hover { transform: scale(1.2); box-shadow: 0 3px 12px rgba(102, 126, 234, 0.7); }

    .k-value-display {
        font-size: 0.7rem; font-weight: bold; color: #2c3e50; min-width: 20px; text-align: center;
    }

    /* Leaflet Smooth Transition */
    path.leaflet-interactive {
        transition: fill 0.75s linear, fill-opacity 0.75s linear, stroke 0.75s linear;
    }

    #italyMap { width: 100%; height: 100%; border-radius: 4px; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
    .leaflet-container { user-select: none; -webkit-user-select: none; }
    #clusterChart { cursor: crosshair; }
    #bubbleChart { cursor: grab; }
    #bubbleChart:active { cursor: grabbing; }
    .btn-update { background: var(--accent); color: white; border: none; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 0.75rem; }
</style>
</head>
<body>

    <header>
        <div style="font-weight:700; font-size: 1rem; letter-spacing: 0.5px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">
            Visual Analytics Dashboard by Pagnotta, Sorrentini and Trionfetti
        </div>
        <button class="btn-update" onclick="loadClusteringData()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; padding: 6px 16px; border-radius: 8px; font-weight: 600; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3); transition: all 0.3s;">üîÑ Refresh</button>
    </header>

    <div class="dashboard-container">
        <div class="col">
            <div class="card map-wrapper">
                <div class="card-header">
                    <span style="font-weight: 700; letter-spacing: 0.3px;">Geospatial Distribution</span>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <label style="font-size: 0.65rem; font-weight: normal;">Variable:</label>
                        <select id="map-variable-select" class="mini-select" onchange="updateMapVariable()">
                            <option value="none" selected>None</option>
                        </select>
                    </div>
                </div>
                <div id="italyMap"></div>
            </div>
            <div class="card cluster-wrapper">
                <div class="card-header" style="background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);">
                    <span> Dimensionality Reduction (based on PCA and K-Means) <span class="k-display" id="k-display"></span></span>
                    <div class="cluster-controls">
                        <label style="font-size: 0.65rem;">K:</label>
                        <select id="k-mode-select" class="mini-select" onchange="loadClusteringData()">
                            <option value="auto" selected>Auto</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                            <option value="6">6</option>
                            <option value="7">7</option>
                            <option value="8">8</option>
                        </select>
                    </div>
                </div>
                <div class="chart-container">
                    <div class="cluster-chart-area">
                        <canvas id="clusterChart"></canvas>
                        <div id="cluster-loading" class="loading-overlay">
                            <span>Loading clustering data...</span>
                        </div>
                    </div>
                    <div class="temporal-controls-area">
                        <div id="temporal-controls" class="temporal-controls active">
                            <div class="playback-controls" style="gap: 8px;">
                                <button class="btn-mini" id="play-pause-btn" onclick="togglePlayPause()" style="min-width: 80px;">
                                    <span id="play-pause-icon">‚ñ∂</span> <span id="play-pause-text">Play</span>
                                </button>
                                <button class="btn-mini" onclick="resetAnimation()" title="Reset to start">‚Ü∫ Reset</button>
                                <button class="btn-mini active" onclick="showOverview()" id="overview-btn" title="Show overall analysis">üîç Overview</button>
                                <div style="display: flex; align-items: center; gap: 6px; margin-left: 8px;">
                                    <label style="font-size: 0.65rem; font-weight: 600; color: #7f8c8d;">Speed:</label>
                                    <select id="speed-select" class="mini-select" style="min-width: 85px;">
                                        <option value="6000">Slow</option>
                                        <option value="3000" selected>Normal</option>
                                        <option value="1200">Fast</option>
                                        <option value="400">Ultra</option>
                                    </select>
                                </div>
                                <span class="year-display" id="year-display" style="margin-left: auto;">2022</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 8px; margin-top: 8px;">
                                <span style="font-size: 0.65rem; color: #7f8c8d; min-width: 35px;">Start</span>
                                <input type="range" id="timeline-slider" class="timeline-slider overview-mode"
                                       min="0" max="100" value="0" oninput="onTimelineChange()" style="flex: 1;">
                                <span style="font-size: 0.65rem; color: #7f8c8d; min-width: 35px; text-align: right;">End</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="col">
            <div class="card bubble-wrapper" style="overflow: hidden;">
                <div class="card-header">
                    <span>Bubble Chart - Variable Comparison</span>
                    <div style="display: flex; gap: 6px; align-items: center; font-size: 0.65rem;">
                        <label>X:</label>
                        <select id="bubble-x-select" class="mini-select" onchange="onBubbleVariableChange()"></select>
                        <label>Y:</label>
                        <select id="bubble-y-select" class="mini-select" onchange="onBubbleVariableChange()"></select>
                        <label>Size:</label>
                        <select id="bubble-size-select" class="mini-select" onchange="onBubbleVariableChange()"></select>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="bubbleChart"></canvas>
                    <div class="bubble-controls-overlay">
                        <div class="zoom-controls">
                            <button class="control-btn" onclick="resetBubbleZoom()" title="Reset">‚ü≤</button>
                            <button class="control-btn" onclick="bubbleZoomIn()" title="Zoom In">+</button>
                            <button class="control-btn" onclick="bubbleZoomOut()" title="Zoom Out">‚àí</button>
                            <button class="control-btn" onclick="clearTrails()" title="Clear Trails">‚úñ</button>
                        </div>
                        <!-- Log-scale controls removed: bubble chart uses linear axes only -->
                    </div>
                </div>
            </div>

            <div class="card stats-wrapper">
                <div class="card-header" style="background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%); flex-direction: column; align-items: flex-start; gap: 10px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                        <span style="font-weight: 700; letter-spacing: 0.3px;">Top K Diverse Variables</span>
                        <button class="btn-mini" id="manual-mode-btn" onclick="toggleManualModeButton()" style="font-size: 0.65rem; padding: 4px 10px;">
                            <span id="manual-mode-icon"></span> <span id="manual-mode-text">Manual</span>
                        </button>
                    </div>
                    <div style="font-size:0.65rem; color:#6b7280; margin-top:6px; max-width:100%; line-height:1.2;">
                        Shows variables that best distinguish the selected regions from clusters. Colors use an 8-bin normalized scale per column.
                    </div>
                    <!-- K slider (visibile solo in auto mode) -->
                    <div class="k-slider-container" id="k-slider-container" style="display: flex; align-items: center; gap: 10px; width: 100%;">
                        <label style="font-size: 0.7rem; font-weight: 600; color: #7f8c8d; min-width: 20px;">K:</label>
                        <input type="range" id="k-slider" class="k-slider"
                               min="1" max="32" value="5"
                               oninput="updateTopKValue()" style="flex: 1;">
                        <span id="k-value-display" class="k-value-display" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 4px 10px; border-radius: 6px; min-width: 35px; text-align: center; font-weight: 700; box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);">5</span>
                    </div>
                    <!-- Manual selection counter (visibile solo in manual mode) -->
                    <div id="manual-selection-info" style="display: none; width: 100%; padding: 6px 12px; background: linear-gradient(135deg, rgba(240, 147, 251, 0.1) 0%, rgba(245, 87, 108, 0.1) 100%); border-radius: 6px; border-left: 3px solid #f5576c;">
                        <span style="font-size: 0.7rem; font-weight: 600; color: #f5576c;">‚úì Manual Mode: <span id="selected-vars-count">0</span> variables selected</span>
                    </div>
                </div>
                <div id="manual-variables-list" class="manual-variables-list">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 2px solid #3498db;">
                        <span style="font-weight: bold; font-size: 0.75rem; color: #2c3e50;">Select Variables:</span>
                        <button class="btn-mini" onclick="closeManualSelection()" style="background: #27ae60;">‚úì OK</button>
                    </div>
                    <div id="manual-variables-checkboxes">
                        <!-- Populated dynamically with checkboxes -->
                    </div>
                </div>
                <div class="table-scroll">
                    <table>
                        <thead id="tableHead"></thead>
                        <tbody id="tableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Server configuration
        const SERVER_BASE = 'http://127.0.0.1:5000';

        /**
         * Generates Line and Point datasets for historical trails
         * @param {string[]} regions - Array of region names to draw trails for
         * @param {number} currentYear - The current year (trails stop here)
         */
        function getTrailDatasets(regions, currentYear) {
            const trailDatasets = [];

            // Get all available years from cache, sorted
            const cachedYears = Object.keys(allYearsDataCache)
                .map(y => parseInt(y))
                .sort((a, b) => a - b)
                .filter(y => y <= currentYear); // Only history up to current year

            if (cachedYears.length < 2) return []; // Need at least 2 points for a line

            regions.forEach(region => {
                const trailPoints = [];

                // 1. Collect Data Points across history
                cachedYears.forEach(year => {
                    const yearData = allYearsDataCache[year];
                    if (!yearData) return;

                    // Find X, Y, Size for this region in this year
                    const xRow = yearData.find(r => r.region === region && r.data_type === bubbleXVar);
                    const yRow = yearData.find(r => r.region === region && r.data_type === bubbleYVar);
                    const sRow = yearData.find(r => r.region === region && r.data_type === bubbleSizeVar);

                    if (xRow && yRow) {
                        // Determine radius (scale historical dots smaller than current bubble)
                        const sizeVal = sRow ? sRow.value : 0;
                        // Simple radius calculation or reuse your existing scaler
                        const radius = Math.max(2, Math.sqrt(Math.abs(sizeVal)) * 0.8);

                        trailPoints.push({
                            x: xRow.value,
                            y: yRow.value,
                            r: radius,
                            year: year
                        });
                    }
                });

                if (trailPoints.length === 0) return;

                // 2. Get Color (Cluster Color)
                // Find cluster ID for this region to match color
                let color = '#999'; // default
                if (currentClustering && currentClustering.regions) {
                    const idx = currentClustering.regions.indexOf(region);
                    if (idx >= 0) {
                        const clusterId = currentClustering.clusters[idx];
                        color = clusterColors[clusterId % clusterColors.length];
                    }
                }

                // 3. Create LINE Dataset (The path)
                trailDatasets.push({
                    type: 'line',
                    label: `${region}_Trail_Line`,
                    data: trailPoints,
                    borderColor: hexToRgba(color, 0.4), // Lower opacity for trail line
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 0, // Hide points on the line layer
                    fill: false,
                    tension: 0.2, // Slight curve for smoothness
                    borderDash: [5, 5], // Optional: Dashed line for history
                    order: 10, // Draw behind everything
                    clip: false,
                    animation: false // No animation for the static trail history
                });

                // 4. Create POINTS Dataset (Historical dots)
                trailDatasets.push({
                    type: 'bubble',
                    label: `${region}_Trail_Points`,
                    data: trailPoints,
                    backgroundColor: hexToRgba(color, 0.3),
                    borderColor: hexToRgba(color, 0.5),
                    borderWidth: 1,
                    pointRadius: trailPoints.map(p => 2), // Small fixed size for history dots
                    pointHoverRadius: 4,
                    order: 9,
                    clip: false,
                    animation: false
                });

                // 5. Add a label for the start year (Optional, cool effect)
                if (trailPoints.length > 0) {
                    const startPoint = trailPoints[0];
                    // You could add a specific text label plugin here if desired
                }
            });

            return trailDatasets;
        }

        /**
         * Helper: Get historical points for a region up to (but not including) the current year
         */
        function getHistoricalPoints(region, currentYearLimit) {
            const history = [];

            // Sort years to ensure line is drawn in correct order
            const years = Object.keys(allYearsDataCache)
                .map(y => parseInt(y))
                .sort((a, b) => a - b)
                .filter(y => y < currentYearLimit); // Strictly LESS than current year

            years.forEach(year => {
                const yearData = allYearsDataCache[year];
                if (!yearData) return;

                const xRow = yearData.find(r => r.region === region && r.data_type === bubbleXVar);
                const yRow = yearData.find(r => r.region === region && r.data_type === bubbleYVar);
                const sRow = yearData.find(r => r.region === region && r.data_type === bubbleSizeVar);

                if (xRow && yRow) {
                    // Scale historical dots slightly smaller
                    const sizeVal = sRow ? sRow.value : 0;
                    const radius = Math.max(2, Math.sqrt(Math.abs(sizeVal)) * 0.8);

                    history.push({
                        x: xRow.value,
                        y: yRow.value,
                        r: radius,
                        year: year
                    });
                }
            });

            return history;
        }

        // Region coordinates for map
        const regionCoords = {
            "Abruzzo": [42.35, 13.39],
            "Basilicata": [40.63, 15.80],
            "Calabria": [38.91, 16.59],
            "Campania": [40.83, 14.25],
            "Emilia-Romagna": [44.49, 11.34],
            "Friuli-Venezia Giulia": [46.06, 13.24],
            "Lazio": [41.89, 12.51],
            "Liguria": [44.41, 8.95],
            "Lombardia": [45.46, 9.19],
            "Marche": [43.62, 13.51],
            "Molise": [41.67, 14.60],
            "Piemonte": [45.07, 7.69],
            "Puglia": [41.13, 16.87],
            "Sardegna": [39.22, 9.12],
            "Sicilia": [38.12, 13.36],
            "Toscana": [43.77, 11.25],
            "Trentino-Alto Adige/S√ºdtirol": [46.07, 11.12],
            "Umbria": [43.11, 12.39],
            "Valle d'Aosta/Vall√©e d'Aoste": [45.74, 7.43],
            "Veneto": [45.44, 12.32]
        };

        // Map setup
        const map = L.map('italyMap', {
            center: [42.0, 12.5],  // Moved south from 42.5 to 41.8 to show Sicily better
            zoom: 4.6,  // Slightly smaller default zoom
            // Allow fractional zoom levels (disable integer snapping)
            zoomSnap: 0.1,
            zoomDelta: 0.1,
            zoomControl: false,
            dragging: false,
            scrollWheelZoom: false,
            doubleClickZoom: false,
            boxZoom: false,
            keyboard: false,
            touchZoom: false
        });
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png').addTo(map);
        const mapLayer = L.layerGroup().addTo(map);

        // Cluster colors (8 colors for max 8 clusters)
        const clusterColors = [
            '#d62728', '#1f77b4', '#2ca02c', '#9467bd',
            '#ff7f0e', '#8c564b', '#e377c2', '#17becf',
            '#bcbd22', '#7f7f7f'
        ];

        // State variables
        let currentDataSet = [];
        let currentClustering = null;
        let selectedRegionNames = [];
        let isDrawing = false;
        let brushStart = null;
        let brushEnd = null;
        let hasMoved = false;
        let currentYearlyData = null;
        let commonIndicators = ['BIRTHRATE', 'DEATHRATE', 'LIFEEXP0T', 'DEPENDRATE', 'MARRATE'];
        let topKValue = 5; // Default K value for top variables
        let isManualTopKMode = false; // Toggle for manual variable selection
        let manualSelectedVariables = []; // User-selected variables in manual mode
        let manualListClickHandler = null; // Handler to close manual list when clicking outside
        let isOverviewMode = true; // Start in overview mode by default
        let isAnimationPlaying = false; // Track animation state for play/pause

        // ============================================
        // BUBBLE CHART STATE MANAGEMENT
        // ============================================

        // Variable configuration for axes and bubble size
        let bubbleXVar = 'BIRTHRATE';
        let bubbleYVar = 'LIFEEXP0T';
        let bubbleSizeVar = 'DEATHRATE';

        // Trail tracking for temporal mode
        let bubbleTrails = {}; // region -> array of {x, y, size, year}
        let clickedBubbleRegions = []; // Regions selected for trail visualization

        // Hover state for interactive crosshair
        let bubbleHoverState = {
            active: false,
            region: null,
            position: { x: 0, y: 0 },
            values: { x: 0, y: 0, size: 0 }
        };

        // PCP state - REMOVED ZOOM/PAN
        let indicatorNames = {}; // Map DATA_TYPE -> readable name
        let selectedVariable = null; // Currently selected variable for map coloring
        let globalScales = {}; // Global min-max for each variable across all years
        let globalScalesCalculated = false;  // Track if scales are already calculated
        let geoJsonLayer = null; // GeoJSON layer for regions
        let regionGeoJson = null; // GeoJSON data

        // Cache for all yearly data (year -> data array)
        let allYearsDataCache = {};

        // When true, keep bubble chart axes fixed to overview ranges even in temporal mode
        let bubbleForceOverviewInTemporal = true;
        // When true, keep cluster PCA chart axes fixed to global ranges in temporal mode
        let clusterForceOverviewInTemporal = true;
        let clusterGlobalRanges = null; // { xmin, xmax, ymin, ymax }
        let clusterGlobalRangesCalculated = false;

        // Animation variables
        let timeseriesData = null;
        let animationInterval = null;
        let currentTimeIndex = 0;

        // Brush selection plugin
        const brushPlugin = {
            id: 'brushPlugin',
            afterDatasetsDraw: (chart) => {
                if (brushStart && brushEnd) {
                    const ctx = chart.ctx;
                    ctx.save();
                    ctx.fillStyle = 'rgba(52, 152, 219, 0.2)';
                    ctx.strokeStyle = 'rgba(52, 152, 219, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);

                    const x = Math.min(brushStart.x, brushEnd.x);
                    const y = Math.min(brushStart.y, brushEnd.y);
                    const w = Math.abs(brushEnd.x - brushStart.x);
                    const h = Math.abs(brushEnd.y - brushStart.y);

                    ctx.fillRect(x, y, w, h);
                    ctx.strokeRect(x, y, w, h);
                    ctx.restore();
                }
            }
        };

        // Chart setup
        const clusterChart = new Chart(document.getElementById('clusterChart'), {
            type: 'scatter',
            data: { datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    duration: 0 // Disable Chart.js animation to have smooth manual interpolation
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            font: { size: 10 },
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const region = context.dataset.regionNames[context.dataIndex];
                                const cluster = context.dataset.label;
                                return `${region} - ${cluster}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: { display: true, text: 'Component 1', font: { size: 10 } },
                        min: -10,
                        max: 10
                    },
                    y: {
                        title: { display: true, text: 'Component 2', font: { size: 10 } },
                        min: -10,
                        max: 10
                    }
                }
            },
            plugins: [brushPlugin]
        });

        // ============================================
        // BUBBLE CHART PLUGINS
        // ============================================

        /**
         * Plugin: Year Watermark - Displays current year in temporal mode
         */
        const bubbleYearWatermarkPlugin = {
            id: 'bubbleYearWatermark',
            beforeDatasetsDraw: (chart) => {
                if (!timeseriesData || currentTimeIndex >= timeseriesData.length) return;

                const ctx = chart.ctx;
                const chartArea = chart.chartArea;
                const centerX = (chartArea.left + chartArea.right) / 2;
                const centerY = (chartArea.top + chartArea.bottom) / 2;
                const year = timeseriesData[currentTimeIndex].year;

                ctx.save();
                ctx.font = 'bold 90px Segoe UI';
                ctx.fillStyle = 'rgba(200, 200, 200, 0.12)';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(year, centerX, centerY);
                ctx.restore();
            }
        };

        /**
         * Plugin: Interactive Crosshair - Shows crosshair lines and axis labels
         */
        const bubbleCrosshairPlugin = {
            id: 'bubbleCrosshair',
            afterDatasetsDraw: (chart) => {
                if (!bubbleHoverState.active) return;

                const ctx = chart.ctx;
                const chartArea = chart.chartArea;
                const { x, y } = bubbleHoverState.position;
                const { x: xVal, y: yVal } = bubbleHoverState.values;

                ctx.save();

                // Draw crosshair lines
                ctx.setLineDash([6, 4]);
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.6)';
                ctx.lineWidth = 1.5;

                // Vertical line
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, chartArea.bottom);
                ctx.stroke();

                // Horizontal line
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(chartArea.left, y);
                ctx.stroke();

                // Draw axis labels
                ctx.setLineDash([]);
                ctx.font = 'bold 11px Segoe UI';

                // X-axis label
                const xText = xVal.toFixed(2);
                const xTextWidth = ctx.measureText(xText).width;
                const xLabelX = Math.max(chartArea.left + 5, Math.min(x - xTextWidth / 2, chartArea.right - xTextWidth - 5));
                const xLabelY = chartArea.bottom + 18;

                drawLabelBox(ctx, xLabelX, xLabelY, xText, '#3498db');

                // Y-axis label
                const yText = yVal.toFixed(2);
                const yTextWidth = ctx.measureText(yText).width;
                const yLabelX = chartArea.left - yTextWidth - 12;
                const yLabelY = y + 5;

                drawLabelBox(ctx, yLabelX, yLabelY, yText, '#e74c3c');

                ctx.restore();
            }
        };

        /**
         * Plugin: Enhanced Tooltip - Shows detailed bubble information
         */
        const bubbleTooltipPlugin = {
            id: 'bubbleTooltip',
            afterDatasetsDraw: (chart) => {
                if (!bubbleHoverState.active || !bubbleHoverState.region) return;

                const ctx = chart.ctx;
                const chartArea = chart.chartArea;
                const { x, y } = bubbleHoverState.position;
                const { x: xVal, y: yVal, size: sizeVal } = bubbleHoverState.values;
                const region = bubbleHoverState.region;

                // Tooltip content
                const xName = indicatorNames[bubbleXVar] || bubbleXVar;
                const yName = indicatorNames[bubbleYVar] || bubbleYVar;
                const sizeName = indicatorNames[bubbleSizeVar] || bubbleSizeVar;

                const lines = [
                    { label: 'Region', value: region, bold: true },
                    { label: xName, value: xVal.toFixed(2) },
                    { label: yName, value: yVal.toFixed(2) },
                    { label: sizeName, value: sizeVal.toFixed(2), color: '#ff7f00' }
                ];

                // Calculate tooltip dimensions
                ctx.font = '11px Segoe UI';
                const lineHeight = 18;
                const padding = 10;
                const maxLabelWidth = Math.max(...lines.map(l => ctx.measureText(l.label + ':').width));
                const maxValueWidth = Math.max(...lines.map(l => ctx.measureText(l.value).width));
                const tooltipWidth = maxLabelWidth + maxValueWidth + padding * 3;
                const tooltipHeight = lines.length * lineHeight + padding * 2;

                // Position tooltip (avoid edges)
                let tooltipX = x + 15;
                let tooltipY = y - tooltipHeight / 2;

                if (tooltipX + tooltipWidth > chartArea.right) {
                    tooltipX = x - tooltipWidth - 15;
                }
                if (tooltipY < chartArea.top) {
                    tooltipY = chartArea.top;
                }
                if (tooltipY + tooltipHeight > chartArea.bottom) {
                    tooltipY = chartArea.bottom - tooltipHeight;
                }

                ctx.save();

                // Draw tooltip background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 1;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                roundRect(ctx, tooltipX, tooltipY, tooltipWidth, tooltipHeight, 6);
                ctx.fill();
                ctx.shadowColor = 'transparent';
                ctx.stroke();

                // Draw tooltip content
                let currentY = tooltipY + padding + 12;
                lines.forEach(line => {
                    // Label
                    ctx.font = line.bold ? 'bold 12px Segoe UI' : '11px Segoe UI';
                    ctx.fillStyle = '#555';
                    ctx.textAlign = 'left';
                    ctx.fillText(line.label + ':', tooltipX + padding, currentY);

                    // Value
                    ctx.font = line.bold ? 'bold 12px Segoe UI' : 'bold 11px Segoe UI';
                    ctx.fillStyle = line.color || '#2c3e50';
                    ctx.textAlign = 'right';
                    ctx.fillText(line.value, tooltipX + tooltipWidth - padding, currentY);

                    currentY += lineHeight;
                });

                ctx.restore();
            }
        };

        // ============================================
        // BUBBLE CHART HELPER FUNCTIONS
        // ============================================

        /**
         * Draw a label box with background and border
         */
        function drawLabelBox(ctx, x, y, text, accentColor = '#3498db') {
            const textWidth = ctx.measureText(text).width;
            const boxPadding = 5;
            const boxWidth = textWidth + boxPadding * 2;
            const boxHeight = 18;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(x - boxPadding, y - 13, boxWidth, boxHeight);

            ctx.strokeStyle = accentColor;
            ctx.lineWidth = 2;
            ctx.strokeRect(x - boxPadding, y - 13, boxWidth, boxHeight);

            ctx.fillStyle = '#2c3e50';
            ctx.fillText(text, x, y);
        }

        /**
         * Draw rounded rectangle
         */
        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        /**
         * Convert hex color to rgba
         */
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        /**
         * Calculate optimal axis range for bubble chart
         */
        function calculateAxisRange(values, paddingPercent = 0.1) {
            if (!values || values.length === 0) {
                return { min: 0, max: 100 };
            }

            const min = Math.min(...values);
            const max = Math.max(...values);
            const range = max - min;

            // Add padding to prevent bubbles from touching edges
            // If range is very small, use a minimum padding
            const padding = range > 0 ? range * paddingPercent : Math.abs(max) * paddingPercent || 1;

            return {
                min: min - padding,
                max: max + padding
            };
        }

        /**
         * Calculate bubble radius
         */
        function calculateBubbleRadius(sizeValue, minSize = 5, maxSize = 18) {
            return Math.sqrt(Math.abs(sizeValue)) * 1.5 + minSize;
        }

        /**
         * Calculate bubble radius using per-year min/max scaling
         */
        function calculateBubbleRadiusForYear(value, yearMin, yearMax, minSize = 5, maxSize = 18) {
            if (value === null || value === undefined || isNaN(value)) return minSize;
            if (yearMin === null || yearMax === null || yearMin === undefined || yearMax === undefined) {
                return calculateBubbleRadius(value, minSize, maxSize);
            }
            if (yearMin === yearMax) return (minSize + maxSize) / 2;
            const t = (Number(value) - Number(yearMin)) / (Number(yearMax) - Number(yearMin));
            const clamped = Math.max(0, Math.min(1, t));
            return minSize + clamped * (maxSize - minSize);
        }

        /**
         * Get region data for bubble chart
         */
        function getRegionBubbleData(regionName) {
            const values = {};

            if (!currentYearlyData) return null;

            currentYearlyData.forEach(row => {
                if (row.region === regionName) {
                    values[row.data_type] = row.value;
                }
            });

            const xVal = values[bubbleXVar];
            const yVal = values[bubbleYVar];

            // Handle "none" size variable
            let sizeVal = 0;
            if (bubbleSizeVar !== 'none') {
                sizeVal = values[bubbleSizeVar];
            }

            if (xVal === undefined || yVal === undefined || (bubbleSizeVar !== 'none' && sizeVal === undefined)) {
                return null;
            }

            return { x: xVal, y: yVal, size: sizeVal, allValues: values };
        }

        /**
         * Get bubble color based on size value (heatmap)
         */
        function getBubbleColor(sizeValue) {
            const sizeScale = globalScales[bubbleSizeVar];
            if (!sizeScale || sizeScale.max === sizeScale.min) {
                return '#fdae6b';
            }

            const rawNorm = (sizeValue - sizeScale.min) / (sizeScale.max - sizeScale.min);
            const normalized = Math.max(0, Math.min(1, rawNorm));
            return getHeatmapColor(normalized);
        }

        /**
         * Reset bubble zoom
         */
        function resetBubbleZoom() {
            bubbleChart.resetZoom();
            bubbleHoverState.active = false;
            bubbleChart.update('none');
        }

        /**
         * Zoom in on bubble chart
         */
        function bubbleZoomIn() {
            bubbleChart.zoom(1.2);
        }

        /**
         * Zoom out on bubble chart
         */
        function bubbleZoomOut() {
            bubbleChart.zoom(0.8);
        }

        // Log-scale toggles removed: bubble chart uses linear axes only

        // ============================================
        // BUBBLE CHART EVENT HANDLERS
        // ============================================

/**
         * Handle bubble click events
         * UPDATED: Syncs with global selection to update Map, PCA, and Table
         */
        function handleBubbleClick(event, elements) {
            if (elements.length > 0) {
                const datasetIndex = elements[0].datasetIndex;
                const dataset = bubbleChart.data.datasets[datasetIndex];

                // Guard: Ensure we clicked a main region bubble (not a trail line/point)
                if (!dataset.regionName) return;

                const region = dataset.regionName;

                // --- 1. Update Global Selection (Syncs with Map & PCA) ---
                const selIndex = selectedRegionNames.indexOf(region);
                if (selIndex >= 0) {
                    selectedRegionNames.splice(selIndex, 1); // Deselect if already selected
                } else {
                    selectedRegionNames.push(region); // Select if not present
                }

                // --- 2. Update Bubble Trails (Keep existing visual history logic) ---
                // We sync the trails with the selection so selected regions show their history path
                const trailIndex = clickedBubbleRegions.indexOf(region);
                if (trailIndex >= 0) {
                    clickedBubbleRegions.splice(trailIndex, 1);
                } else {
                    clickedBubbleRegions.push(region);
                    // Ensure trail data is built for this region
                    buildFullTrailForRegion(region);
                }

                console.log(`Bubble Click: Toggled ${region}. Total Selected: ${selectedRegionNames.length}`);

                // --- 3. Trigger Global Updates ---
                // This function updates the Cluster Chart styling, Map styling,
                // and internally calls updateLinkedViews() to redraw the Bubble Chart
                updateSelectionHighlight();

            } else {
                // --- 4. Background Click ---
                // If the user clicks on empty space, clear all selections
                if (selectedRegionNames.length > 0 || clickedBubbleRegions.length > 0) {
                    selectedRegionNames = [];
                    clickedBubbleRegions = [];
                    console.log('Selections cleared via Bubble Chart background click');

                    // Refresh all views to remove highlights
                    updateSelectionHighlight();
                }
            }
        }

        /**
         * Handle bubble hover events
         */
        function handleBubbleHover(event, elements) {
            const canvas = event.native.target;

            if (elements.length > 0) {
                const element = elements[0];
                const datasetIndex = element.datasetIndex;
                const dataIndex = element.index;
                const dataset = bubbleChart.data.datasets[datasetIndex];
                const dataPoint = dataset.data[dataIndex];

                if (!dataPoint || !dataset.regionName) {
                    canvas.style.cursor = 'default';
                    bubbleHoverState.active = false;
                    bubbleChart.update('none');
                    return;
                }

                canvas.style.cursor = 'pointer';

                const xScale = bubbleChart.scales.x;
                const yScale = bubbleChart.scales.y;

                bubbleHoverState.active = true;
                bubbleHoverState.region = dataset.regionName;
                bubbleHoverState.position = {
                    x: xScale.getPixelForValue(dataPoint.x),
                    y: yScale.getPixelForValue(dataPoint.y)
                };
                bubbleHoverState.values = {
                    x: dataPoint.x,
                    y: dataPoint.y,
                    size: getRegionBubbleData(dataset.regionName)?.size || 0
                };

                bubbleChart.update('none');
            } else {
                canvas.style.cursor = 'default';
                bubbleHoverState.active = false;
                bubbleChart.update('none');
            }
        }

// ============================================
        // BUBBLE CHART CONFIGURATION & UPDATE LOGIC
        // ============================================

        // 1. Initialize the Chart Instance (Single Declaration)
        const bubbleChart = new Chart(document.getElementById('bubbleChart'), {
            type: 'bubble',
            data: { datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                // SMOOTH ANIMATION CONFIGURATION
                animation: {
                    duration: 750,
                    easing: 'easeOutQuart',
                    delay: 0
                },
                transitions: {
                    active: {
                        animation: { duration: 750, delay: 0 }
                    }
                },
                layout: {
                    padding: { left: 5, right: 5, top: 5, bottom: 5 }
                },
                scales: {
                    x: {
                        type: 'linear',
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Birth Rate',
                            font: { size: 11, weight: '600' },
                            color: '#2c3e50'
                        },
                        grid: { color: 'rgba(0, 0, 0, 0.05)' },
                        ticks: { font: { size: 10 }, maxTicksLimit: 10 },
                        min: 0, max: 100
                    },
                    y: {
                        type: 'linear',
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Life Expectancy',
                            font: { size: 11, weight: '600' },
                            color: '#2c3e50'
                        },
                        grid: { color: 'rgba(0, 0, 0, 0.05)' },
                        ticks: { font: { size: 10 }, maxTicksLimit: 10 },
                        min: 0, max: 100
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: { enabled: false },
                    zoom: {
                        pan: { enabled: true, mode: 'xy', threshold: 5 },
                        zoom: { wheel: { enabled: false }, pinch: { enabled: false }, mode: 'xy' }
                    }
                },
                onClick: handleBubbleClick,
                onHover: (event, elements) => {
                    const canvas = event.native.target;
                    canvas.style.cursor = 'default';
                    if (elements.length > 0 && elements[0].element) {
                        handleBubbleHover(event, elements);
                    } else {
                        bubbleHoverState.active = false;
                        // Use 'none' here to not interrupt main animation
                        bubbleChart.update('none');
                    }
                }
            },
            plugins: [
                bubbleYearWatermarkPlugin,
                bubbleCrosshairPlugin,
                bubbleTooltipPlugin
            ]
        });

        // 2. The Missing Update Function (With Smooth Transition Logic)
        function updateBubbleChart() {
    if (!currentYearlyData || !currentClustering) {
        clearBubbleChart();
        return;
    }

    // 1. Determine Current Year
    let currentYear = 2022;
    if (timeseriesData && timeseriesData[currentTimeIndex]) {
        currentYear = timeseriesData[currentTimeIndex].year;
    }

    // 2. Calculate Global Min/Max for Bubble Size (Consistency)
    // ... (Your existing scaling logic) ...
    let yearSizeVals = currentYearlyData
        .filter(r => r && (r.data_type === bubbleSizeVar || r.data_type === bubbleSizeVar.toString()))
        .map(r => Number(r.value))
        .filter(v => v !== null && v !== undefined && !isNaN(v));

    if (yearSizeVals.length === 0) {
        yearSizeVals = currentYearlyData.map(r => {
             if (r && r[bubbleSizeVar] !== undefined) return Number(r[bubbleSizeVar]);
             return null;
        }).filter(v => v !== null && v !== undefined && !isNaN(v));
    }
    const yearMin = yearSizeVals.length > 0 ? Math.min(...yearSizeVals) : null;
    const yearMax = yearSizeVals.length > 0 ? Math.max(...yearSizeVals) : null;

    // 3. Prepare Data Map
    const newDatasetMap = new Map();
    const regionsToShow = Object.keys(regionCoords);

    // Combine selection sources (Map click or Bubble click)
    const regionsToTrail = [...new Set([...selectedRegionNames, ...clickedBubbleRegions])];

    // --- MAIN LOOP ---
    regionsToShow.forEach(region => {
        const regionData = getRegionBubbleData(region);
        if (!regionData) return;

        const { x: xVal, y: yVal, size: sizeVal } = regionData;
        const regionIdx = currentClustering.regions.indexOf(region);
        const clusterId = regionIdx >= 0 ? currentClustering.clusters[regionIdx] : 0;
        const fillColor = clusterColors[clusterId % clusterColors.length];

        // 4. Highlight Logic
        const isSelected = selectedRegionNames.includes(region);
        const isClicked = clickedBubbleRegions.includes(region);
        const isHighlighted = isSelected || isClicked;
        const anyHighlight = regionsToTrail.length > 0;

        const opacity = !anyHighlight || isHighlighted ? 1.0 : 0.15;
        const strokeColor = isHighlighted ? '#333' : fillColor;
        const radius = calculateBubbleRadiusForYear(sizeVal, yearMin, yearMax, 5, 25);

        // --- GAPMINDER TRAIL LOGIC ---
        // Only generate trails if this specific region is highlighted
        if (isHighlighted) {
            // A. Get History (Up to current year - 1)
            const historyPoints = getHistoricalPoints(region, currentYear);

            // B. Create Line Data: History + CURRENT POINT
            // This ensures the line connects physically to the big bubble
            const lineData = [
                ...historyPoints,
                { x: xVal, y: yVal, r: radius } // Append current position
            ];

            // C. Add Line Dataset (The path)
            newDatasetMap.set(`${region}_Trail_Line`, {
                type: 'line',
                label: `${region}_Trail_Line`,
                data: lineData,
                borderColor: hexToRgba(fillColor, 0.6),
                backgroundColor: 'transparent',
                borderWidth: 2,
                pointRadius: 0, // No points on the line itself
                fill: false,
                tension: 0.2,
                borderDash: [4, 4],
                order: 10, // Behind everything
                clip: false,
                animation: false // No animation for history lines
            });

            // D. Add History Dots Dataset (The small previous points)
            // Use ONLY historyPoints (don't draw a small dot under the big current bubble)
            if (historyPoints.length > 0) {
                newDatasetMap.set(`${region}_Trail_Points`, {
                    type: 'bubble',
                    label: `${region}_Trail_Points`,
                    data: historyPoints,
                    backgroundColor: hexToRgba(fillColor, 0.3),
                    borderColor: hexToRgba(fillColor, 0.5),
                    borderWidth: 1,
                    pointRadius: historyPoints.map(p => 3), // Fixed small size
                    pointHoverRadius: 5,
                    order: 9,
                    clip: false,
                    animation: false
                });
            }
        }

        // --- CURRENT BUBBLE DATASET ---
        newDatasetMap.set(region, {
            type: 'bubble',
            label: region,
            data: [{ x: xVal, y: yVal, r: radius }],
            backgroundColor: hexToRgba(fillColor, opacity),
            borderColor: strokeColor,
            borderWidth: isHighlighted ? 3 : 1,
            hoverBorderWidth: 4,
            hoverBorderColor: '#000',
            pointRadius: radius,
            pointHoverRadius: radius + 2,
            regionName: region,
            clip: false,
            order: 1 // Top priority
        });
    });

    // 5. Update Axes
    const { xRange, yRange } = calculateDynamicAxisRanges();
    bubbleChart.options.scales.x.min = xRange.min;
    bubbleChart.options.scales.x.max = xRange.max;
    bubbleChart.options.scales.y.min = yRange.min;
    bubbleChart.options.scales.y.max = yRange.max;

    // 6. Sync Datasets to Chart
    for (let i = bubbleChart.data.datasets.length - 1; i >= 0; i--) {
        const existingDs = bubbleChart.data.datasets[i];

        if (newDatasetMap.has(existingDs.label)) {
            const newDs = newDatasetMap.get(existingDs.label);

            // For the main bubble, we update in-place to allow animation
            if (existingDs.type === 'bubble' && !existingDs.label.includes('Trail')) {
                 existingDs.data = newDs.data;
                 existingDs.backgroundColor = newDs.backgroundColor;
                 existingDs.borderColor = newDs.borderColor;
                 existingDs.borderWidth = newDs.borderWidth;
                 existingDs.pointRadius = newDs.pointRadius;
                 // Don't update 'order' or 'type' continuously to save overhead
            } else {
                 // For trails (lines/dots), we replace data directly
                 // This snaps the line to the new position immediately
                 Object.assign(existingDs, newDs);
            }
            newDatasetMap.delete(existingDs.label);
        } else {
            bubbleChart.data.datasets.splice(i, 1);
        }
    }

    // Add remaining new datasets (new selections)
    newDatasetMap.forEach(newDs => {
        bubbleChart.data.datasets.push(newDs);
    });

    updateBubbleAxisLabels();
    bubbleChart.update();
}

        // ============================================
        // BUBBLE CHART VARIABLE CHANGE & UPDATE
        // ============================================

        /**
         * Handle variable selection change for bubble chart axes
         */
        function onBubbleVariableChange() {
            const xSelect = document.getElementById('bubble-x-select');
            const ySelect = document.getElementById('bubble-y-select');
            const sizeSelect = document.getElementById('bubble-size-select');

            if (xSelect?.value) bubbleXVar = xSelect.value;
            if (ySelect?.value) bubbleYVar = ySelect.value;
            if (sizeSelect?.value) bubbleSizeVar = sizeSelect.value;

            console.log('Bubble variables updated:', { x: bubbleXVar, y: bubbleYVar, size: bubbleSizeVar });

            // Clear trails and selections when changing variables
            bubbleTrails = {};
            clickedBubbleRegions = [];

            // Reset zoom state to ensure proper scaling
            bubbleChart.resetZoom();

            // Update chart with new variables
            updateBubbleChart();
        }

        /**
         * Calculate dynamic axis ranges based on current mode and selection
         */
        function calculateDynamicAxisRanges() {
            // Always compute axis ranges over ALL regions so axes remain stable
            // even when some regions are selected/highlighted.
            const regionsToConsider = Object.keys(regionCoords);
            const hasSelection = selectedRegionNames.length > 0;
            console.log(`üìä Calculating axis ranges - Mode: ${isOverviewMode ? 'OVERVIEW' : 'TEMPORAL'}, Selection ignored (using ALL regions). Selected count: ${hasSelection ? selectedRegionNames.length : 0}`);

            let xValues = [];
            let yValues = [];

            const forceOverview = !isOverviewMode && bubbleForceOverviewInTemporal;

            if (isOverviewMode || forceOverview) {
                // OVERVIEW MODE: use only current year data for selected/all regions
                console.log('üìå Overview mode: using current year data only', forceOverview ? '(FORCED while temporal)' : '');
                regionsToConsider.forEach(region => {
                    currentYearlyData.forEach(row => {
                        if (row.region === region) {
                            if (row.data_type === bubbleXVar) xValues.push(row.value);
                            if (row.data_type === bubbleYVar) yValues.push(row.value);
                        }
                    });
                });
            } else {
                // TEMPORAL MODE: use all years for selected/all regions
                console.log('üìå Temporal mode: calculating from ALL years and regions');

                // Collect all years from cache
                const cachedYears = Object.keys(allYearsDataCache).map(y => parseInt(y)).sort((a, b) => a - b);
                console.log(`üìÖ Using ${cachedYears.length} cached years: ${cachedYears.length > 0 ? cachedYears[0] + ' to ' + cachedYears[cachedYears.length - 1] : 'none'}`);

                if (cachedYears.length > 0) {
                    // For each cached year, extract X and Y values for the regions to consider
                    cachedYears.forEach(year => {
                        const yearData = allYearsDataCache[year];
                        if (!yearData || !Array.isArray(yearData)) return;

                        // Iterate through all rows in this year's data
                        yearData.forEach(row => {
                            // Check if this row belongs to a region we care about
                            if (regionsToConsider.includes(row.region)) {
                                // Collect X values
                                if (row.data_type === bubbleXVar && row.value !== null && row.value !== undefined) {
                                    xValues.push(row.value);
                                }
                                // Collect Y values
                                if (row.data_type === bubbleYVar && row.value !== null && row.value !== undefined) {
                                    yValues.push(row.value);
                                }
                            }
                        });
                    });

                    console.log(`üìä Collected ${xValues.length} X values (${bubbleXVar}) and ${yValues.length} Y values (${bubbleYVar}) from cache`);

                    if (xValues.length > 0) {
                        console.log(`   X range: ${Math.min(...xValues).toFixed(2)} to ${Math.max(...xValues).toFixed(2)}`);
                    }
                    if (yValues.length > 0) {
                        console.log(`   Y range: ${Math.min(...yValues).toFixed(2)} to ${Math.max(...yValues).toFixed(2)}`);
                    }
                } else {
                    console.warn('‚ö†Ô∏è No cached years available, falling back to global scales');
                    xValues = [globalScales[bubbleXVar]?.min || 0, globalScales[bubbleXVar]?.max || 1];
                    yValues = [globalScales[bubbleYVar]?.min || 0, globalScales[bubbleYVar]?.max || 1];
                }
            }

            // Calculate ranges with padding for better visualization
            const xRange = xValues.length > 0 ? calculateAxisRange(xValues, 0.15) : { min: 0, max: 1 };
            const yRange = yValues.length > 0 ? calculateAxisRange(yValues, 0.15) : { min: 0, max: 1 };

            console.log(`‚úÖ Calculated ranges - X(${bubbleXVar}): [${xRange.min.toFixed(2)}, ${xRange.max.toFixed(2)}], Y(${bubbleYVar}): [${yRange.min.toFixed(2)}, ${yRange.max.toFixed(2)}]`);

            return { xRange, yRange };
        }


        /**
         * Update bubble chart axis labels
         */
        function updateBubbleAxisLabels() {
            const xLabelFull = indicatorNames[bubbleXVar] || bubbleXVar;
            const yLabelFull = indicatorNames[bubbleYVar] || bubbleYVar;
            const sizeLabelFull = indicatorNames[bubbleSizeVar] || bubbleSizeVar;

            // Truncate readable labels at first '(' to match dropdown display
            function truncateAtParen(str) {
                if (!str) return str;
                const idx = str.indexOf('(');
                return idx > 0 ? str.substring(0, idx).trim() : str;
            }

            const xLabel = truncateAtParen(xLabelFull);
            const yLabel = truncateAtParen(yLabelFull);
            const sizeLabel = truncateAtParen(sizeLabelFull);

            if (!bubbleChart.options.scales.x.title) {
                bubbleChart.options.scales.x.title = { display: true };
            }
            if (!bubbleChart.options.scales.y.title) {
                bubbleChart.options.scales.y.title = { display: true };
            }

            bubbleChart.options.scales.x.title.text = xLabel;
            bubbleChart.options.scales.x.title.display = true;
            // Show only the Y variable readable name (truncate removed the parenthetical)
            bubbleChart.options.scales.y.title.text = yLabel;
            bubbleChart.options.scales.y.title.display = true;
        }

        /**
         * Clear bubble chart
         */
        function clearBubbleChart() {
            bubbleChart.data.datasets = [];
            bubbleHoverState.active = false;
            bubbleChart.update('none');
        }

        // ============================================
        // SERVER & DATA LOADING
        // ============================================

        // Fetch clustering data from server
        async function loadClusteringData() {
            const method = 'pca';  // Fixed to PCA
            const clustering = 'kmeans';  // Fixed to K-means
            const kMode = document.getElementById('k-mode-select').value;
            const isManualK = kMode !== 'auto';
            const manualK = isManualK ? parseInt(kMode) : null;

            console.log(`üìä Loading clustering: mode=${kMode}, isManualK=${isManualK}, manualK=${manualK}, isOverviewMode=${isOverviewMode}`);

            // Ensure the year display matches the current overview/temporal mode
            setYearDisplayVisibility();

            // Do NOT reset global scales - they should be calculated once and reused

            showLoading(true);

            try {
                // Check if we should load in overview mode (single year) or temporal mode
                if (isOverviewMode) {
                    // Overview mode - load single year clustering
                    let endpoint;
                    if (isManualK && manualK && !isNaN(manualK)) {
                        console.log(`üìç Overview mode with manual K=${manualK}`);
                        endpoint = `${SERVER_BASE}/clustering_manual?year=2022&method=${method}&clustering=${clustering}&k=${manualK}`;
                    } else {
                        console.log('üìç Overview mode with auto K');
                        endpoint = `${SERVER_BASE}/clustering?method=${method}&clustering=${clustering}`;
                    }

                    console.log(`üåê Fetching: ${endpoint}`);
                    const response = await fetch(endpoint);
                    const data = await response.json();

                    if (data.status === 'success') {
                        const uniqueClusters = new Set(data.clusters);
                        console.log(`üì¶ Server response - Requested K=${manualK || 'auto'}, Received ${uniqueClusters.size} clusters:`, Array.from(uniqueClusters).sort((a,b)=>a-b));
                        console.log(`üìã Server K field: k_optimal=${data.k_optimal}, k_used=${data.k_used || 'N/A'}`);
                        currentClustering = data;
                        updateClusterChart(data);
                        loadYearlyData(2022);
                    } else {
                        alert('Error loading clustering: ' + data.message);
                    }
                } else {
                    // Temporal mode
                    if (isManualK && manualK && !isNaN(manualK)) {
                        console.log(`üìç Temporal mode with manual K=${manualK}`);
                        // Manual K + Temporal: load each year with manual K
                        const df = await fetch(`${SERVER_BASE}/yearly_data?year=2022`);
                        const tempData = await df.json();

                        // Get all years from dataset
                        const years = [];
                        for (let year = 2002; year <= 2050; year++) {
                            years.push(year);
                        }

                        console.log(`üîÑ Loading ${years.length} years with K=${manualK}...`);
                        // Load clustering for each year with manual K
                        const timeseries = [];
                        for (const year of years) {
                            const response = await fetch(`${SERVER_BASE}/clustering_manual?year=${year}&method=${method}&clustering=${clustering}&k=${manualK}`);
                            const data = await response.json();
                            if (data.status === 'success') {
                                if (year === 2002) {
                                    // Log first year as sample
                                    const uniqueClusters = new Set(data.clusters);
                                    console.log(`üì¶ Year ${year} - Requested K=${manualK}, Received ${uniqueClusters.size} clusters:`, Array.from(uniqueClusters).sort((a,b)=>a-b));
                                    console.log(`üìã Server response fields: k_optimal=${data.k_optimal}, k_used=${data.k_used || 'N/A'}`);
                                }
                                timeseries.push(data);
                            }
                        }

                        if (timeseries.length > 0) {
                            timeseriesData = timeseries;
                            // Compute cluster global ranges for fixed axes in temporal mode
                            computeClusterGlobalRanges();

                            // Preload all years to calculate global scales
                            if (!globalScalesCalculated) {
                                console.log('Preloading all years to calculate global scales...');
                                await preloadAllYearsForScales(years);
                            }

                            setupTimeline();
                            updateClusterChart(timeseriesData[0]);
                            loadYearlyData(timeseriesData[0].year);
                        } else {
                            alert('Error loading manual timeseries');
                        }
                    } else {
                        console.log('üìç Temporal mode with auto K (precomputed)');
                        // Auto K + Temporal: use precomputed
                        const response = await fetch(`${SERVER_BASE}/clustering_timeseries?method=${method}&clustering=${clustering}`);
                        const data = await response.json();

                        if (data.status === 'success') {
                            timeseriesData = data.timeseries || [];

                            // Compute cluster global ranges for fixed axes in temporal mode
                            computeClusterGlobalRanges();

                            // Ensure timeseriesData contains entries up to 2050 when possible
                            try {
                                // Build set of existing years
                                const existing = new Set(timeseriesData.map(ts => ts.year));

                                // Determine candidate k to use for missing-year requests (try using k from first entry)
                                const candidateK = (timeseriesData[0] && timeseriesData[0].k_optimal) || data.k_optimal || null;

                                const missingYears = [];
                                for (let y = 2002; y <= 2050; y++) {
                                    if (!existing.has(y)) missingYears.push(y);
                                }

                                if (missingYears.length > 0) {
                                    console.log(`Attempting to fetch ${missingYears.length} missing years for timeline (may be slow)...`);
                                    for (const year of missingYears) {
                                        try {
                                            // Try to fetch clustering for the missing year using clustering_manual if k available
                                            let resp, respJson;
                                            if (candidateK) {
                                                resp = await fetch(`${SERVER_BASE}/clustering_manual?year=${year}&method=${method}&clustering=${clustering}&k=${candidateK}`);
                                                respJson = await resp.json();
                                            } else {
                                                // If no k candidate, skip fetching per-year clustering (server may not support auto per-year endpoint)
                                                console.warn('No candidate k available; skipping per-year clustering fetch for year', year);
                                                continue;
                                            }

                                            if (respJson && respJson.status === 'success') {
                                                timeseriesData.push(respJson);
                                                existing.add(year);
                                                // Cache yearly data for scales
                                                if (respJson.year && respJson.data) allYearsDataCache[respJson.year] = respJson.data;
                                            } else {
                                                console.warn('Failed to fetch clustering for year', year, respJson && respJson.message);
                                            }
                                        } catch (err) {
                                            console.warn('Error fetching clustering for year', year, err);
                                        }
                                    }

                                    // Sort timeseriesData by year ascending
                                    timeseriesData.sort((a, b) => a.year - b.year);
                                }
                            } catch (err) {
                                console.error('Error while augmenting timeseriesData:', err);
                            }

                            // Preload all years to calculate global scales
                            if (!globalScalesCalculated) {
                                console.log('Preloading all years to calculate global scales (extended to 2002-2050)...');
                                const fullYears = [];
                                for (let y = 2002; y <= 2050; y++) fullYears.push(y);
                                await preloadAllYearsForScales(fullYears);
                            }

                            if (timeseriesData.length === 0) {
                                alert('Error loading timeseries: no data returned');
                            } else {
                                setupTimeline();
                                updateClusterChart(timeseriesData[0]);
                                loadYearlyData(timeseriesData[0].year);
                            }
                        } else {
                            alert('Error loading timeseries: ' + data.message);
                        }
                    }
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to load clustering data. Make sure the server is running.');
            } finally {
                showLoading(false);
            }
        }

        async function loadYearlyData(year) {
            // 1. CHECK CACHE FIRST (Critical for smooth sync)
            // If we have the data, update immediately without network delay
            if (allYearsDataCache[year]) {
                currentYearlyData = allYearsDataCache[year];

                // Ensure indicator names are mapped
                if (Object.keys(indicatorNames).length === 0) {
                     currentYearlyData.forEach(row => {
                        if (row.indicator && row.data_type && !indicatorNames[row.data_type]) {
                            const fullName = row.indicator;
                            indicatorNames[row.data_type] = fullName.split('(')[0].trim();
                        }
                    });
                    populateVariableDropdown();
                }

                // Ensure scales are ready
                if (!globalScalesCalculated) calculateGlobalScales();

                // Update trails
                try { updateBubbleTrails(year); } catch (e) { }

                // Update Linked Views (Bubble Chart, Table, Map)
                updateLinkedViews();
                return;
            }

            // 2. FALLBACK TO FETCH (Only if not cached)
            try {
                console.log('Loading yearly data for year:', year);
                const response = await fetch(`${SERVER_BASE}/yearly_data?year=${year}`);
                const data = await response.json();

                if (data.status === 'success') {
                    currentYearlyData = data.data;

                    // Cache the result for next time
                    allYearsDataCache[year] = currentYearlyData;

                    currentYearlyData.forEach(row => {
                        if (row.indicator && row.data_type && !indicatorNames[row.data_type]) {
                            const fullName = row.indicator;
                            indicatorNames[row.data_type] = fullName.split('(')[0].trim();
                        }
                    });
                    populateVariableDropdown();
                    if (!globalScalesCalculated) calculateGlobalScales();
                    try { updateBubbleTrails(year); } catch (e) { console.warn(e); }

                    updateLinkedViews();
                } else {
                    console.error('Error loading yearly data:', data.message);
                }
            } catch (error) {
                console.error('Error fetching yearly data:', error);
            }
        }

        /**
         * Preload all years to calculate global scales once
         */
        async function preloadAllYearsForScales(years) {
            try {
                console.log('‚è≥ Calcolo scale globali da', years.length, 'anni (2002-2050)...');

                // Keep existing scales if already calculated - don't reset
                if (globalScalesCalculated) {
                    console.log('‚úÖ Scale gi√† calcolate - riutilizzo valori salvati');
                    return;
                }

                // Initialize globalScales only if empty
                if (Object.keys(globalScales).length === 0) {
                    globalScales = {};
                }

                // Fetch data for all years
                for (const year of years) {
                    const response = await fetch(`${SERVER_BASE}/yearly_data?year=${year}`);
                    const data = await response.json();

                    if (data.status === 'success') {
                        const yearData = data.data;

                        // Store in cache for later use by calculateDynamicAxisRanges
                        allYearsDataCache[year] = yearData;

                        const variables = [...new Set(yearData.map(row => row.data_type))];

                        // For each variable, track global min=0 and max across all years
                        variables.forEach(variable => {
                            const values = yearData
                                .filter(row => row.data_type === variable)
                                .map(row => row.value)
                                .filter(v => v !== null && v !== undefined);

                            if (values.length > 0) {
                                const currentMax = Math.max(...values);

                                if (!globalScales[variable]) {
                                    // First time - set min to 0, max to current, and pre-calculate axis max
                                    globalScales[variable] = {
                                        min: 0,
                                        max: currentMax,
                                        axisMax: currentMax * 1.15  // Pre-calculate axis max with 15% buffer
                                    };
                                } else {
                                    // Update max and recalculate axis max
                                    globalScales[variable].max = Math.max(globalScales[variable].max, currentMax);
                                    globalScales[variable].axisMax = globalScales[variable].max * 1.15;
                                }
                            }
                        });
                    }
                }

                globalScalesCalculated = true;
                console.log('‚úÖ SCALE GLOBALI SALVATE per', Object.keys(globalScales).length, 'variabili');
                console.log('üìä Range fissi salvati (riutilizzati per sempre):');
                Object.entries(globalScales).forEach(([variable, scale]) => {
                    console.log(`   ${variable}: max=${scale.max.toFixed(2)} ‚Üí axisMax=${scale.axisMax.toFixed(2)}`);
                });
            } catch (error) {
                console.error('Error preloading years for scales:', error);
            }
        }

        /**
         * Update bubble trails for temporal animation
         */
        // Compute global cluster axes ranges across the loaded timeseriesData
        function computeClusterGlobalRanges() {
            if (!timeseriesData || timeseriesData.length === 0) return;
            let xs = [];
            let ys = [];
            timeseriesData.forEach(ts => {
                const pts = ts.points || [];
                const regs = ts.regions || [];
                if (pts.length === regs.length) {
                    pts.forEach(p => { xs.push(p[0]); ys.push(p[1]); });
                } else {
                    // If server returned centroids only, expand using clusters mapping
                    const clusters = ts.clusters || [];
                    const centroidMap = {};
                    for (let i=0;i<pts.length;i++) centroidMap[i] = pts[i];
                    for (let i=0;i<clusters.length;i++) {
                        const cid = clusters[i];
                        const cp = centroidMap[cid];
                        if (cp && cp.length === 2 && isFinite(cp[0]) && isFinite(cp[1])) {
                            xs.push(cp[0]); ys.push(cp[1]);
                        } else {
                            // Missing centroid for this cluster-year; skip instead of using 0,0
                            console.warn('Missing centroid for cluster', cid, 'in year', ts.year);
                        }
                    }
                }
            });

            if (xs.length > 0) {
                const xmin = Math.min(...xs);
                const xmax = Math.max(...xs);
                const ymin = Math.min(...ys);
                const ymax = Math.max(...ys);
                clusterGlobalRanges = { xmin, xmax, ymin, ymax };
                clusterGlobalRangesCalculated = true;
                console.log('üìê clusterGlobalRanges computed:', clusterGlobalRanges);
            }
        }

        function updateBubbleTrails(year) {
            const isTemporalMode = true; // Always in temporal mode
            if (!isTemporalMode || !currentYearlyData) return;

            clickedBubbleRegions.forEach(clickedRegion => {
                if (!bubbleTrails[clickedRegion]) {
                    bubbleTrails[clickedRegion] = [];
                }

                const regionData = getRegionBubbleData(clickedRegion);
                if (!regionData) return;

                bubbleTrails[clickedRegion].push({
                    x: regionData.x,
                    y: regionData.y,
                    size: regionData.size,
                    year: year
                });
            });
        }

        /**
         * Clear all historical trail lines and trail points produced by clicks
         */
        function clearTrails() {
            bubbleTrails = {};
            clickedBubbleRegions = [];
            console.log('Cleared bubble trails and trail points');
            // Rebuild/update charts and linked views
            updateLinkedViews();
        }

        /**
         * Build a full historical trail for a region using cached yearly data (if available)
         * It collects positions (x,y,size,year) from earliest cached year up to current year.
         */
        function buildFullTrailForRegion(regionName) {
            // Initialize
            bubbleTrails[regionName] = [];

            console.log(`üîç Building trail for ${regionName}, vars: X=${bubbleXVar}, Y=${bubbleYVar}, Size=${bubbleSizeVar}`);

            // Prefer cached all years if available
            const years = Object.keys(allYearsDataCache).map(y => parseInt(y)).sort((a,b)=>a-b);
            console.log(`üìÖ Found ${years.length} cached years:`, years.length > 0 ? `${years[0]} to ${years[years.length-1]}` : 'none');

            if (years.length > 0) {
                years.forEach(year => {
                    const yearData = allYearsDataCache[year];
                    if (!Array.isArray(yearData)) return;
                    const xRow = yearData.find(r => r.region === regionName && r.data_type === bubbleXVar);
                    const yRow = yearData.find(r => r.region === regionName && r.data_type === bubbleYVar);
                    const sRow = yearData.find(r => r.region === regionName && r.data_type === bubbleSizeVar);
                    if (xRow && yRow) {
                        bubbleTrails[regionName].push({
                            x: xRow.value,
                            y: yRow.value,
                            size: sRow ? sRow.value : 0,
                            year: year
                        });
                    }
                });
                console.log(`‚úÖ Trail built with ${bubbleTrails[regionName].length} points from cache`);
            } else if (timeseriesData && timeseriesData.length > 0) {
                // Fallback: use timeseriesData points' positions (if available)
                timeseriesData.forEach(ts => {
                    const year = ts.year;
                    // Find index of region in ts.regions
                    const idx = ts.regions ? ts.regions.indexOf(regionName) : -1;
                    if (idx >= 0 && ts.points && ts.points[idx]) {
                        const pt = ts.points[idx];
                        // size unknown here; attempt to look up in allYearsDataCache (unlikely), else 0
                        let sizeVal = 0;
                        if (allYearsDataCache[year]) {
                            const sRow = allYearsDataCache[year].find(r => r.region === regionName && r.data_type === bubbleSizeVar);
                            if (sRow) sizeVal = sRow.value;
                        }
                        bubbleTrails[regionName].push({ x: pt[0], y: pt[1], size: sizeVal, year: year });
                    }
                });
                console.log(`‚úÖ Trail built with ${bubbleTrails[regionName].length} points from timeseriesData fallback`);
            } else {
                console.warn('‚ö†Ô∏è No data available to build trail - neither allYearsDataCache nor timeseriesData');
            }

            if (bubbleTrails[regionName].length === 0) {
                console.error(`‚ùå Trail for ${regionName} is EMPTY after build attempt`);
            }
        }

        function updateClusterChart(data) {
            // console.log('Updating cluster chart...');
            currentClustering = data;

            // 1. Process Data Points
            // Ensure we have a valid point for each region, handling cases where
            // the server returns only centroids or sparse data.
            let perRegionPoints = [];
            const numRegions = (data.regions || []).length;
            const numPoints = (data.points || []).length;
            const uniqueClusters = Array.from(new Set(data.clusters || [])).sort((a,b)=>a-b);

            if (numPoints === numRegions) {
                // 1:1 mapping (ideal case)
                perRegionPoints = data.points.slice();
            } else if (numPoints === uniqueClusters.length) {
                // Centroid-only case: map centroids to regions based on cluster ID
                const centroidMap = {};
                for (let ci = 0; ci < data.points.length; ci++) centroidMap[ci] = data.points[ci];
                for (let i = 0; i < numRegions; i++) {
                    const cid = data.clusters[i];
                    const cp = centroidMap[cid];
                    perRegionPoints.push((cp && cp.length === 2 && isFinite(cp[0]) && isFinite(cp[1])) ? cp : null);
                }
            } else {
                // Invalid data: pad with nulls
                for (let i = 0; i < numRegions; i++) perRegionPoints.push(null);
            }

            // 2. Group by Cluster for Chart.js Datasets
            const clusterGroups = {};
            for (let i = 0; i < numRegions; i++) {
                const clusterId = data.clusters[i];
                if (!clusterGroups[clusterId]) {
                    clusterGroups[clusterId] = { points: [], regions: [] };
                }
                clusterGroups[clusterId].points.push(perRegionPoints[i]);
                clusterGroups[clusterId].regions.push(data.regions[i]);
            }

            // 3. Create Datasets
            const datasets = [];
            Object.keys(clusterGroups).sort((a, b) => parseInt(a) - parseInt(b)).forEach((clusterId, idx) => {
                const group = clusterGroups[clusterId];

                // Determine styling based on selection state
                const pointRadii = group.regions.map(region => selectedRegionNames.includes(region) ? 8 : 5);
                const pointBorderWidths = group.regions.map(region => selectedRegionNames.includes(region) ? 3 : 0);

                datasets.push({
                    label: `Cluster ${parseInt(clusterId) + 1}`,
                    data: group.points.map(p => ({ x: p[0], y: p[1] })),
                    backgroundColor: clusterColors[idx % clusterColors.length],
                    pointRadius: pointRadii,
                    pointBorderWidth: pointBorderWidths,
                    pointBorderColor: '#000',
                    pointHoverRadius: 7,
                    pointHoverBorderWidth: 2,
                    regionNames: group.regions
                });
            });

            clusterChart.data.datasets = datasets;

            // 4. Update Scales
            // Use global ranges in temporal mode to prevent axes "dancing" during animation
            try {
                // Collect only valid points for calculation
                const allPoints = [].concat(...Object.values(clusterGroups).map(g => g.points))
                    .filter(p => Array.isArray(p) && p.length === 2 && isFinite(p[0]) && isFinite(p[1]));

                if (allPoints.length > 0) {
                    if (!isOverviewMode && clusterForceOverviewInTemporal && clusterGlobalRangesCalculated) {
                        // Use FIXED global ranges computed from timeseries history
                        const xmin = clusterGlobalRanges.xmin;
                        const xmax = clusterGlobalRanges.xmax;
                        const ymin = clusterGlobalRanges.ymin;
                        const ymax = clusterGlobalRanges.ymax;

                        // Add small padding
                        const padX = (xmax - xmin) * 0.08 || 1;
                        const padY = (ymax - ymin) * 0.08 || 1;

                        clusterChart.options.scales.x.min = xmin - padX;
                        clusterChart.options.scales.x.max = xmax + padX;
                        clusterChart.options.scales.y.min = ymin - padY;
                        clusterChart.options.scales.y.max = ymax + padY;
                    } else {
                        // Dynamic auto-scaling (Overview mode or first load)
                        const xs = allPoints.map(p => p[0]);
                        const ys = allPoints.map(p => p[1]);
                        const xmin = Math.min(...xs);
                        const xmax = Math.max(...xs);
                        const ymin = Math.min(...ys);
                        const ymax = Math.max(...ys);

                        const padX = (xmax - xmin) * 0.08 || 1;
                        const padY = (ymax - ymin) * 0.08 || 1;

                        clusterChart.options.scales.x.min = xmin - padX;
                        clusterChart.options.scales.x.max = xmax + padX;
                        clusterChart.options.scales.y.min = ymin - padY;
                        clusterChart.options.scales.y.max = ymax + padY;
                    }
                }
            } catch (e) {
                console.warn('Could not autoscale cluster axes', e);
            }

            // Update chart without animation (interpolation handled by loop)
            clusterChart.update('none');

            // Update K display text
            const kDisplay = document.getElementById('k-display');
            if (kDisplay) {
                const kVal = data.k_optimal !== undefined ? data.k_optimal : (uniqueClusters.length || 0);
                kDisplay.textContent = `(Num. of clusters: ${kVal})`;
            }

            // Store current dataset for brush selection logic
            currentDataSet = data.regions.map((region, idx) => ({
                name: region,
                cluster: data.clusters[idx],
                point: (perRegionPoints && perRegionPoints[idx]) ? perRegionPoints[idx] : null
            }));

            // CRITICAL FIX: Removed updateMap() and updateMapStyles()
            // Map updates are now triggered exclusively via updateLinkedViews()
            // to ensure synchronization with the Bubble Chart.
        }

        function updateSelectionHighlight() {
            if (!currentClustering) return;

            // Update point styles based on selection
            clusterChart.data.datasets.forEach(dataset => {
                const pointRadii = [];
                const pointBorderWidths = [];

                dataset.regionNames.forEach(region => {
                    const isSelected = selectedRegionNames.includes(region);
                    pointRadii.push(isSelected ? 8 : 5);
                    pointBorderWidths.push(isSelected ? 3 : 0);
                });

                dataset.pointRadius = pointRadii;
                dataset.pointBorderWidth = pointBorderWidths;
            });

            clusterChart.update('none');

            // Update map styles
            updateMapStyles();

            // Update linked views
            updateLinkedViews();
        }

        function updateMap(data) {
            if (!geoJsonLayer) return;

            console.log('Updating map with clustering data');
            updateMapStyles();
        }

        function updateMapStyles() {
            if (!geoJsonLayer || !currentClustering) return;

            // Count unique clusters for debugging
            const uniqueClusters = new Set(currentClustering.clusters);
            console.log(`üó∫Ô∏è Updating map styles with ${uniqueClusters.size} clusters:`, Array.from(uniqueClusters).sort((a,b)=>a-b));

            // Remove existing selection layers if any
            if (window.selectionLayer) {
                try { map.removeLayer(window.selectionLayer); } catch (e) {}
                window.selectionLayer = null;
            }
            if (window.selectionLayerOuter) {
                try { map.removeLayer(window.selectionLayerOuter); } catch (e) {}
                window.selectionLayerOuter = null;
            }

            // Create features for selected regions with black border
            const selectedFeatures = [];

            geoJsonLayer.eachLayer(layer => {
                const regionName = getRegionNameFromFeature(layer.feature);
                const regionIdx = currentClustering.regions.indexOf(regionName);

                if (regionIdx >= 0) {
                    const clusterId = currentClustering.clusters[regionIdx];
                    const clusterColor = clusterColors[clusterId % clusterColors.length];

                    // Default: use cluster color as fill
                    let fillColor = clusterColor;
                    let fillOpacity = 0.5;

                    // If a variable is selected, color by variable value instead
                    if (selectedVariable && selectedVariable !== 'none' && currentYearlyData) {
                        const value = getRegionVariableValue(regionName, selectedVariable);
                        // If value is missing, mark region as 'no data' with gray
                        if (value === null || value === undefined || Number.isNaN(value)) {
                            fillColor = '#e6e7eb';
                            fillOpacity = 0.6;
                        } else if (globalScales[selectedVariable]) {
                            const scale = globalScales[selectedVariable];
                            const range = scale.max - scale.min;
                            const rawNorm = range > 0 ? (value - scale.min) / range : 0.5;
                            const normalized = Math.max(0, Math.min(1, rawNorm));
                            fillColor = getHeatmapColor(normalized);
                            fillOpacity = 0.7;
                        }
                    }

                    // Check if region is selected
                    const isSelected = selectedRegionNames.includes(regionName);

                    // Base style with cluster color border
                    layer.setStyle({
                        fillColor: fillColor,
                        fillOpacity: fillOpacity,
                        weight: 3,
                        opacity: 1,
                        color: clusterColor
                    });

                    // If selected, add to selection features for black inner border
                    if (isSelected) {
                        selectedFeatures.push(layer.feature);
                    }
                }
            });

            // Create enhanced double border for selected regions (white + black)
            if (selectedFeatures.length > 0) {
                // Outer white border for contrast
                window.selectionLayerOuter = L.geoJSON({
                    type: 'FeatureCollection',
                    features: selectedFeatures
                }, {
                    style: {
                        fillColor: 'transparent',
                        fillOpacity: 0,
                        weight: 6,
                        opacity: 1,
                        color: '#ffffff',
                        interactive: false
                    },
                    pane: 'overlayPane'
                }).addTo(map);

                // Inner black border
                window.selectionLayer = L.geoJSON({
                    type: 'FeatureCollection',
                    features: selectedFeatures
                }, {
                    style: {
                        fillColor: 'transparent',
                        fillOpacity: 0,
                        weight: 3,
                        opacity: 1,
                        color: '#000000',
                        interactive: false
                    },
                    pane: 'overlayPane'
                }).addTo(map);
            }

            // Build/update legend based on currently selected variable
            try {
                buildMapLegend(selectedVariable);
            } catch (e) {
                console.warn('Failed to build map legend:', e);
            }

            // Force map redraw to ensure cluster color changes are visible
            if (map) {
                map.invalidateSize();
                console.log('üîÑ Map redraw forced');
            }
        }

        /**
         * Build a vertical legend on the left side of the map showing color bins and their ranges
         * Adapts to temporal mode by computing min/max across allYearsDataCache when available
         */
        function buildMapLegend(variable) {
            // Remove existing legend if any
            const existing = document.getElementById('map-legend');
            if (existing) existing.remove();

            if (!variable || variable === 'none') return; // nothing to show

            const container = document.getElementById('italyMap');
            if (!container) return;

            // Determine min/max based on mode
            let min = null, max = null;

            if (!isOverviewMode && Object.keys(allYearsDataCache).length > 0) {
                // Temporal: aggregate across all cached years
                const values = [];
                Object.keys(allYearsDataCache).forEach(y => {
                    const arr = allYearsDataCache[y];
                    arr.forEach(r => {
                        if (r.data_type === variable && r.value !== null && r.value !== undefined) values.push(r.value);
                    });
                });
                if (values.length > 0) {
                    min = Math.min(...values);
                    max = Math.max(...values);
                }
            }

            if ((min === null || max === null) && globalScales[variable]) {
                min = globalScales[variable].min;
                max = globalScales[variable].max;
            }

            if (min === null || max === null) return; // no data available

            // Ensure a non-zero range
            if (min === max) {
                const pad = Math.abs(min) * 0.05 || 1;
                min = min - pad;
                max = max + pad;
            }

            const steps = 7;
            const range = max - min;

            // Helper to format numbers
            function fmt(v) {
                if (Math.abs(v) >= 1000) return v.toFixed(0);
                if (Math.abs(v) >= 10) return v.toFixed(1);
                return v.toFixed(2);
            }

            // Create legend element
            const legend = document.createElement('div');
            legend.id = 'map-legend';
            legend.className = 'map-legend';

            const title = document.createElement('div');
            title.className = 'legend-title';
            const displayName = (indicatorNames[variable] || variable).split('(')[0].trim();
            title.textContent = `${displayName}`;
            legend.appendChild(title);

            // Append items so that lowest range appears at the bottom of the legend
            for (let i = steps - 1; i >= 0; i--) {
                const low = min + (i / steps) * range;
                const high = min + ((i + 1) / steps) * range;
                const midNorm = ((i + 0.5) / steps);
                const color = getHeatmapColor(midNorm);

                const item = document.createElement('div');
                item.className = 'legend-item';

                const sw = document.createElement('div');
                sw.className = 'legend-swatch';
                sw.style.background = color;
                item.appendChild(sw);

                const lbl = document.createElement('div');
                lbl.className = 'legend-label';
                lbl.textContent = `${fmt(low)} ‚Äî ${fmt(high)}`;
                item.appendChild(lbl);

                legend.appendChild(item);
            }

            // Add 'No data' swatch at the bottom to indicate regions without values
            const noDataItem = document.createElement('div');
            noDataItem.className = 'legend-item';
            const noSw = document.createElement('div');
            noSw.className = 'legend-swatch';
            noSw.style.background = '#e6e7eb';
            noDataItem.appendChild(noSw);
            const noLbl = document.createElement('div');
            noLbl.className = 'legend-label';
            noLbl.textContent = 'No data';
            noDataItem.appendChild(noLbl);
            legend.appendChild(noDataItem);

            // Append legend to the map container
            container.style.position = container.style.position || 'relative';
            container.appendChild(legend);
        }

        function toggleTemporal() {
            const isEnabled = document.getElementById('temporal-toggle').checked;
            const controls = document.getElementById('temporal-controls');

            // Clear trails when switching modes
            bubbleTrails = {};
            clickedBubbleRegions = [];

            if (isEnabled) {
                controls.classList.add('active');
                loadClusteringData();
            } else {
                controls.classList.remove('active');
                pauseAnimation();
                loadClusteringData();
            }
        }

        // Temporal animation functions
        function setupTimeline() {
            if (!timeseriesData || timeseriesData.length === 0) return;

            const slider = document.getElementById('timeline-slider');
            slider.max = timeseriesData.length - 1;
            slider.value = 0;
            currentTimeIndex = 0;

            updateYearDisplay();
        }

        function showOverview() {
            // Switch back to overview mode and pause animation
            pauseAnimation();
            isOverviewMode = true;
            setYearDisplayVisibility();

            // Update slider appearance for overview mode
            const slider = document.getElementById('timeline-slider');
            if (slider) {
                slider.classList.add('overview-mode');
            }

            // Highlight overview button
            const overviewBtn = document.getElementById('overview-btn');
            if (overviewBtn) {
                overviewBtn.classList.add('active');
            }

            // Reload clustering in overview mode
            loadClusteringData();
        }

        function interpolatePoints(data1, data2, t) {
            // Interpolate only positions, keep original clusters
            return {
                regions: data1.regions,
                clusters: data1.clusters, // Keep original cluster assignments
                k_optimal: data1.k_optimal,
                year: data1.year + (data2.year - data1.year) * t,
                points: data1.points.map((point, idx) => {
                    const point2 = data2.points[idx];
                    return [
                        point[0] + (point2[0] - point[0]) * t,
                        point[1] + (point2[1] - point[1]) * t
                    ];
                }),
                centroids: data1.centroids
            };
        }

        function interpolateColors(data1, data2, points, t) {
            // Interpolate between cluster assignments (color transition)
            // For simplicity, just switch at t > 0.5
            return {
                regions: data1.regions,
                clusters: t > 0.5 ? data2.clusters : data1.clusters,
                k_optimal: data2.k_optimal,
                year: data2.year,
                points: points,
                centroids: data2.centroids
            };
        }

        // Start playback animation
        // ============================================
        // PLAYBACK CONTROLS - UNIFIED PLAY/PAUSE
        // ============================================

        function togglePlayPause() {
            if (isAnimationPlaying) {
                pauseAnimation();
            } else {
                playAnimation();
            }
        }

        function updatePlayPauseButton(isPlaying) {
            const btn = document.getElementById('play-pause-btn');
            const icon = document.getElementById('play-pause-icon');
            const text = document.getElementById('play-pause-text');

            if (!btn || !icon || !text) return;

            if (isPlaying) {
                icon.textContent = '‚è∏';
                text.textContent = 'Pause';
                btn.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
                btn.style.boxShadow = '0 4px 12px rgba(245, 87, 108, 0.4)';
            } else {
                icon.textContent = '‚ñ∂';
                text.textContent = 'Play';
                btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                btn.style.boxShadow = '0 2px 8px rgba(102, 126, 234, 0.3)';
            }
        }

        function playAnimation() {
            // If in overview mode, switch to temporal mode first
            if (isOverviewMode) {
                isOverviewMode = false;
                setYearDisplayVisibility();

                // Update slider appearance for temporal mode
                const slider = document.getElementById('timeline-slider');
                if (slider) {
                    slider.classList.remove('overview-mode');
                }

                // Remove highlight from overview button
                const overviewBtn = document.getElementById('overview-btn');
                if (overviewBtn) {
                    overviewBtn.classList.remove('active');
                }

                // Reload data in temporal mode
                loadClusteringData().then(() => {
                    // Once loaded, start playing
                    if (timeseriesData && timeseriesData.length > 0) {
                        startPlayback();
                    }
                });
                return;
            }

            if (!timeseriesData || isAnimationPlaying) return;
            startPlayback();
        }

        function startPlayback() {
    // Clear trails when starting animation
    bubbleTrails = {};

    isAnimationPlaying = true;
    updatePlayPauseButton(true);

    const baseSpeed = parseInt(document.getElementById('speed-select').value);

    // Calculate timings
    const movementDuration = baseSpeed * 0.4;  // 40% time for moving
    const colorDuration = baseSpeed * 0.2;      // 20% time for color change
    const pauseDuration = baseSpeed * 0.4;      // 40% time for pause

    // Steps calculation
    const frameRate = baseSpeed < 1000 ? 30 : 50;
    const movementSteps = Math.max(10, Math.floor(movementDuration / frameRate));
    const colorSteps = Math.max(5, Math.floor(colorDuration / frameRate));
    const pauseSteps = Math.floor(pauseDuration / frameRate);

    let currentPhase = 'movement';
    let stepCounter = 0;
    let finalPoints = null;

    // SYNC FIX: Set Bubble Chart animation duration to exactly match
    // the time it takes for Clusters to Move + Change Color.
    // This ensures both charts arrive at the destination at the same time.
    const totalTransitionTime = movementDuration + colorDuration;
    bubbleChart.options.animation.duration = totalTransitionTime;

    animationInterval = setInterval(() => {
        const nextIndex = (currentTimeIndex + 1) % timeseriesData.length;

        if (currentPhase === 'movement') {

            // SYNC FIX: Trigger Bubble/Map update on the FIRST frame of movement
            if (stepCounter === 0) {
                const targetYear = timeseriesData[nextIndex].year;
                // Load data immediately (using cache) so bubbles start moving NOW
                loadYearlyData(targetYear);
            }

            // Cluster Movement Logic
            const progress = Math.min(stepCounter / movementSteps, 1);
            const easedProgress = progress < 0.5
                ? 2 * progress * progress
                : 1 - Math.pow(-2 * progress + 2, 2) / 2;

            const interpolatedData = interpolatePoints(
                timeseriesData[currentTimeIndex],
                timeseriesData[nextIndex],
                easedProgress
            );
            updateClusterChart(interpolatedData);

            // Periodically update table rows if needed (optional)
            if (stepCounter % 10 === 0) updateTopKTable();

            if (progress >= 1) {
                finalPoints = interpolatedData.points;
                currentPhase = 'color';
                stepCounter = 0;
            } else {
                stepCounter++;
            }

        } else if (currentPhase === 'color') {
            // Cluster Color Logic
            const progress = Math.min(stepCounter / colorSteps, 1);
            const colorData = interpolateColors(
                timeseriesData[currentTimeIndex],
                timeseriesData[nextIndex],
                finalPoints,
                progress
            );
            updateClusterChart(colorData);

            if (progress >= 1) {
                currentPhase = 'pause';
                stepCounter = 0;

                // Commit the state change
                currentTimeIndex = nextIndex;
                document.getElementById('timeline-slider').value = currentTimeIndex;
                updateYearDisplay();
            } else {
                stepCounter++;
            }

        } else if (currentPhase === 'pause') {
            stepCounter++;
            if (stepCounter >= pauseSteps) {
                currentPhase = 'movement';
                stepCounter = 0;
            }
        }

    }, frameRate);
}

        function pauseAnimation() {
            isAnimationPlaying = false;
            updatePlayPauseButton(false); // Update button appearance
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        }

        function resetAnimation() {
            pauseAnimation();
            updatePlayPauseButton(false);
            currentTimeIndex = 0;
            bubbleTrails = {}; // Clear trails
            clickedBubbleRegions = []; // Clear clicked regions
            if (timeseriesData && timeseriesData.length > 0) {
                updateClusterChart(timeseriesData[0]);
                document.getElementById('timeline-slider').value = 0;
                updateYearDisplay();
            }
        }

        function onTimelineChange() {
            if (!timeseriesData) return;

            pauseAnimation();
            currentTimeIndex = parseInt(document.getElementById('timeline-slider').value);
            updateClusterChart(timeseriesData[currentTimeIndex]);
            loadYearlyData(timeseriesData[currentTimeIndex].year);
            updateYearDisplay();
        }

        function updateYearDisplay() {
            if (!timeseriesData || currentTimeIndex >= timeseriesData.length) return;
            document.getElementById('year-display').textContent = timeseriesData[currentTimeIndex].year;
        }

        /**
         * Show or hide the small year display based on overview mode.
         */
        function setYearDisplayVisibility() {
            const el = document.getElementById('year-display');
            if (!el) return;
            if (isOverviewMode) {
                el.style.display = 'none';
            } else {
                el.style.display = '';
            }
        }

        function showLoading(show) {
            const overlay = document.getElementById('cluster-loading');
            if (show) {
                overlay.classList.add('active');
            } else {
                overlay.classList.remove('active');
            }
        }

        // Brush selection for cluster chart
        const clusterCanvas = document.getElementById('clusterChart');

        clusterCanvas.addEventListener('mousedown', (e) => {
            if (isAnimationPlaying) return; // Disable during animation

            const rect = clusterCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const chartArea = clusterChart.chartArea;
            if (x >= chartArea.left && x <= chartArea.right &&
                y >= chartArea.top && y <= chartArea.bottom) {
                isDrawing = true;
                brushStart = { x, y };
                brushEnd = { x, y };
                hasMoved = false;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;

            const rect = clusterCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            brushEnd = { x, y };

            // Check if moved beyond threshold (5 pixels)
            const dx = Math.abs(x - brushStart.x);
            const dy = Math.abs(y - brushStart.y);
            if (dx > 5 || dy > 5) {
                hasMoved = true;
            }

            clusterChart.update();
        });

        document.addEventListener('mouseup', () => {
            if (isDrawing) {
                isDrawing = false;

                if (hasMoved) {
                    // Drag selection - select all points in rectangle
                    updateBrushSelection();
                } else {
                    // Single click - select nearest point
                    selectSinglePoint();
                }
            }
        });

        clusterCanvas.addEventListener('dblclick', () => {
            brushStart = null;
            brushEnd = null;
            selectedRegionNames = [];
            updateSelectionHighlight();
            updateLinkedViews();
        });

        function selectSinglePoint() {
            if (!brushStart || !currentClustering) return;

            const xScale = clusterChart.scales.x;
            const yScale = clusterChart.scales.y;

            const clickX = xScale.getValueForPixel(brushStart.x);
            const clickY = yScale.getValueForPixel(brushStart.y);

            // Find nearest point
            let minDistance = Infinity;
            let nearestIndex = -1;

            for (let i = 0; i < currentClustering.points.length; i++) {
                const [px, py] = currentClustering.points[i];
                const distance = Math.sqrt(Math.pow(px - clickX, 2) + Math.pow(py - clickY, 2));

                if (distance < minDistance) {
                    minDistance = distance;
                    nearestIndex = i;
                }
            }

            // Select the nearest point if within reasonable distance
            // (in data units, adjust threshold as needed)
            if (nearestIndex >= 0 && minDistance < 0.5) {
                const regionName = currentClustering.regions[nearestIndex];

                // Toggle point in/out of selection
                const index = selectedRegionNames.indexOf(regionName);
                if (index >= 0) {
                    // Already selected, remove it
                    selectedRegionNames.splice(index, 1);
                    console.log('Deselected region (click):', regionName);
                } else {
                    // Not selected, add it
                    selectedRegionNames.push(regionName);
                    console.log('Selected region (click):', regionName);
                }
            } else {
                // Click was too far from any point - do nothing
                console.log('No point near click');
            }

            // Clear brush rectangle
            brushStart = null;
            brushEnd = null;

            // Update visual highlighting (this calls updateLinkedViews internally)
            updateSelectionHighlight();
        }

        function updateBrushSelection() {
            if (!brushStart || !brushEnd || !currentClustering) return;

            const xScale = clusterChart.scales.x;
            const yScale = clusterChart.scales.y;

            const x1 = Math.min(brushStart.x, brushEnd.x);
            const x2 = Math.max(brushStart.x, brushEnd.x);
            const y1 = Math.min(brushStart.y, brushEnd.y);
            const y2 = Math.max(brushStart.y, brushEnd.y);

            const dataX1 = xScale.getValueForPixel(x1);
            const dataX2 = xScale.getValueForPixel(x2);
            const dataY1 = yScale.getValueForPixel(y2);
            const dataY2 = yScale.getValueForPixel(y1);

            const brushedRegions = [];
            for (let i = 0; i < currentClustering.points.length; i++) {
                const [px, py] = currentClustering.points[i];
                if (px >= dataX1 && px <= dataX2 && py >= dataY1 && py <= dataY2) {
                    brushedRegions.push(currentClustering.regions[i]);
                }
            }

            // Toggle brushed regions in/out of selection
            brushedRegions.forEach(region => {
                const index = selectedRegionNames.indexOf(region);
                if (index >= 0) {
                    // Already selected, remove it
                    selectedRegionNames.splice(index, 1);
                } else {
                    // Not selected, add it
                    selectedRegionNames.push(region);
                }
            });

            console.log('Toggled regions (brush):', brushedRegions);
            console.log('Current selection:', selectedRegionNames);

            // Clear brush rectangle
            brushStart = null;
            brushEnd = null;

            // Update visual highlighting
            updateSelectionHighlight();
        }

        function updateTopKValue() {
            const slider = document.getElementById('k-slider');
            const display = document.getElementById('k-value-display');

            if (!slider || !display) {
                console.error('K slider or display not found!');
                return;
            }

            topKValue = parseInt(slider.value);
            display.textContent = topKValue;
            // Do not modify the slider background when moving it ‚Äî keep CSS default

            console.log('K slider updated to:', topKValue);

            // Update all linked views to reflect new K value
            updateLinkedViews();
        }

        // ============================================
        // MANUAL MODE - NEW BUTTON-BASED INTERFACE
        // ============================================

        function toggleManualModeButton() {
            isManualTopKMode = !isManualTopKMode;

            const btn = document.getElementById('manual-mode-btn');
            const icon = document.getElementById('manual-mode-icon');
            const text = document.getElementById('manual-mode-text');
            const sliderContainer = document.getElementById('k-slider-container');
            const manualList = document.getElementById('manual-variables-list');
            const manualInfo = document.getElementById('manual-selection-info');
            const selectedCount = document.getElementById('selected-vars-count');

            if (!btn || !sliderContainer || !manualList) {
                console.error('‚ùå Manual mode elements not found!');
                return;
            }

            console.log('üîÑ Manual mode:', isManualTopKMode);

            if (isManualTopKMode) {
                // Switch to manual mode
                btn.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
                btn.style.boxShadow = '0 4px 12px rgba(245, 87, 108, 0.4)';
                icon.textContent = '‚úì';
                text.textContent = 'Manual';

                sliderContainer.style.display = 'none';
                if (manualInfo) {
                    manualInfo.style.display = 'block';
                    if (selectedCount) {
                        selectedCount.textContent = manualSelectedVariables.length;
                    }
                }
                manualList.style.display = 'block';
                // Attach click-outside handler to close the manual list when clicking outside
                if (!manualListClickHandler) {
                    manualListClickHandler = function(e) {
                        try {
                            const manualBtn = document.getElementById('manual-mode-btn');
                            const clickedInsideList = e.target && e.target.closest && e.target.closest('#manual-variables-list');
                            const clickedManualBtn = e.target && e.target.closest && e.target.closest('#manual-mode-btn');
                            if (!clickedInsideList && !clickedManualBtn) {
                                closeManualSelection();
                            }
                        } catch (err) { /* ignore */ }
                    };
                    document.addEventListener('click', manualListClickHandler);
                }

                // Get all variables from current data
                if (currentYearlyData && currentYearlyData.length > 0) {
                    const allVariables = [...new Set(currentYearlyData.map(row => row.data_type))].sort();
                    populateManualVariableSelect(allVariables);
                } else {
                    console.warn('‚ö†Ô∏è No data available for manual selection');
                }
            } else {
                // Switch to auto mode
                btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                btn.style.boxShadow = '0 2px 8px rgba(102, 126, 234, 0.3)';
                icon.textContent = 'üìù';
                text.textContent = 'Manual';

                sliderContainer.style.display = 'flex';
                if (manualInfo) {
                    manualInfo.style.display = 'none';
                }
                manualList.style.display = 'none';
                // Remove click-outside handler if attached
                if (manualListClickHandler) {
                    try { document.removeEventListener('click', manualListClickHandler); } catch (e) {}
                    manualListClickHandler = null;
                }
            }

            updateLinkedViews();
        }

        function updateManualSelectionCount() {
            const selectedCount = document.getElementById('selected-vars-count');
            if (selectedCount) {
                selectedCount.textContent = manualSelectedVariables.length;
            }
        }

        function toggleManualMode() {
            const checkbox = document.getElementById('manual-mode-toggle');
            const sliderContainer = document.getElementById('k-slider-container');
            const manualList = document.getElementById('manual-variables-list');

            if (!checkbox || !sliderContainer || !manualList) {
                console.error('‚ùå Manual mode elements not found!');
                return;
            }

            isManualTopKMode = checkbox.checked;
            console.log('üîÑ Manual mode:', isManualTopKMode);

            if (isManualTopKMode) {
                // Switch to manual mode
                sliderContainer.style.display = 'none';
                manualList.classList.add('active');
            } else {
                // Switch to auto mode
                sliderContainer.style.display = 'flex';
                manualList.classList.remove('active');
                manualSelectedVariables = [];
            }

            // Rebuild table and PCP with new mode
            updateLinkedViews();
        }

        function closeManualSelection() {
            const manualList = document.getElementById('manual-variables-list');
            if (manualList) {
                manualList.style.display = 'none';
                manualList.classList.remove('active');
                // Remove global click-outside handler if attached
                if (manualListClickHandler) {
                    try { document.removeEventListener('click', manualListClickHandler); } catch (e) {}
                    manualListClickHandler = null;
                }
            }
            console.log('‚úÖ Manual selection menu closed');
        }

        function populateManualVariableSelect(allVariables) {
            if (!isManualTopKMode) return; // Only populate if in manual mode

            const listContainer = document.getElementById('manual-variables-list');
            if (!listContainer || !allVariables || allVariables.length === 0) {
                console.error('‚ùå Cannot populate manual list - missing container or variables');
                return;
            }

            console.log('üìã Populating manual list with', allVariables.length, 'variables');

            // Clear and repopulate with checkboxes
            listContainer.innerHTML = '';

            // Add styled header with gradient
            const header = document.createElement('div');
            header.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding: 8px 10px; background: #ffffff; border-radius: 6px 6px 0 0; border-bottom: 1px solid rgba(0,0,0,0.06); position: sticky; top: 0; z-index: 50;';

            const title = document.createElement('span');
            title.textContent = 'üìã Select Variables:';
            title.style.cssText = 'font-weight: 700; font-size: 0.8rem; color: #2c3e50; letter-spacing: 0.3px;';

            const resetButton = document.createElement('button');
            resetButton.textContent = 'Reset';
            resetButton.className = 'btn-mini';
            resetButton.style.cssText = 'background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); padding: 6px 14px; box-shadow: 0 2px 6px rgba(192, 57, 43, 0.3);';
            // Reset manual selections (do not close the panel)
            resetButton.onclick = function(e) {
                e.stopPropagation();
                manualSelectedVariables = [];
                // Uncheck all checkboxes in the list
                const boxes = listContainer.querySelectorAll('input[type="checkbox"]');
                boxes.forEach(cb => { cb.checked = false; });
                updateManualSelectionCount();
                updateLinkedViews();
                console.log('üîÅ Manual selections reset');
            };

            header.appendChild(title);
            header.appendChild(resetButton);
            listContainer.appendChild(header);

            const sortedVars = [...allVariables].sort();
            sortedVars.forEach(variable => {
                const item = document.createElement('div');
                item.className = 'variable-checkbox-item';
                item.style.cssText = 'padding: 8px 10px; margin: 4px 0; background: white; border-radius: 6px; transition: all 0.2s; cursor: pointer; border: 1px solid #e0e7ff;';
                item.onmouseenter = function() { this.style.background = 'linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%)'; this.style.borderColor = '#667eea'; };
                item.onmouseleave = function() { this.style.background = 'white'; this.style.borderColor = '#e0e7ff'; };

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `var-${variable}`;
                checkbox.value = variable;
                checkbox.checked = manualSelectedVariables.includes(variable);
                checkbox.style.cssText = 'margin-right: 10px; width: 16px; height: 16px; cursor: pointer; accent-color: #667eea;';

                const label = document.createElement('label');
                label.htmlFor = `var-${variable}`;
                label.textContent = indicatorNames[variable] || variable;
                label.style.cssText = 'cursor: pointer; font-size: 0.75rem; color: #2c3e50; flex: 1;';

                // Make entire row clickable
                item.onclick = function(e) {
                    e.stopPropagation(); // prevent document click-outside handler from firing
                    if (e.target !== checkbox) {
                        checkbox.checked = !checkbox.checked;
                        checkbox.dispatchEvent(new Event('change'));
                    }
                };
                // Prevent checkbox clicks from bubbling to document (avoid accidental close)
                checkbox.addEventListener('click', function(e) { e.stopPropagation(); });

                // Add event listener to checkbox
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        if (!manualSelectedVariables.includes(variable)) {
                            manualSelectedVariables.push(variable);
                        }
                    } else {
                        const idx = manualSelectedVariables.indexOf(variable);
                        if (idx > -1) {
                            manualSelectedVariables.splice(idx, 1);
                        }
                    }
                    console.log('‚úÖ Manual selection updated:', manualSelectedVariables.length, 'variables');
                    updateManualSelectionCount(); // Update counter
                    updateLinkedViews();
                });

                item.appendChild(checkbox);
                item.appendChild(label);
                listContainer.appendChild(item);
            });

            console.log('üìã Populated manual list with', sortedVars.length, 'variables');
        }

        function updateManualSelection() {
            // This function is now handled by individual checkbox listeners
            // Kept for compatibility
        }

        function updateLinkedViews() {
            if (!currentYearlyData || !currentClustering) return;

            // 1. Update Table
            updateTopKTable();

            // 2. Update Bubble Chart (Starts 750ms animation)
            updateBubbleChart();

            // 3. Update Map Colors (Starts 0.75s CSS transition)
            // We update the styles, and because of the CSS, they will fade to the new color
            updateMapStyles();
        }

        // ============================================
        // TOP K TABLE UPDATE
        // ============================================

        // PCP functionality removed - graphics component eliminated from dashboard

        // Note: onBubbleVariableChange() and updateBubbleChart() are already defined above

        function updateTopKTable() {
            console.log('=== updateTopKTable called ===');
            console.log('selectedRegionNames:', selectedRegionNames);
            console.log('currentYearlyData exists:', !!currentYearlyData);
            console.log('currentClustering exists:', !!currentClustering);

            const tableHead = document.getElementById('tableHead');
            const tableBody = document.getElementById('tableBody');

            if (!currentYearlyData || !currentClustering) {
                tableHead.innerHTML = '<tr><th>Select regions to view analysis</th></tr>';
                tableBody.innerHTML = '';
                return;
            }

            // Get all unique clusters
            const uniqueClusters = [...new Set(currentClustering.clusters)].sort((a, b) => a - b);

            // Get all unique data_types (variables)
            const allVariables = [...new Set(currentYearlyData.map(row => row.data_type))];

            // Populate manual select dropdown if needed
            populateManualVariableSelect(allVariables);

            // Update slider max value based on number of variables
            const slider = document.getElementById('k-slider');
            if (slider) {
                slider.max = allVariables.length;
                // Adjust current value if it exceeds max
                if (topKValue > allVariables.length) {
                    topKValue = allVariables.length;
                    slider.value = topKValue;
                    document.getElementById('k-value-display').textContent = topKValue;
                    // Update gradient
                    const percentage = ((topKValue - parseInt(slider.min)) / (parseInt(slider.max) - parseInt(slider.min))) * 100;
                    slider.style.background = `linear-gradient(to right, #3498db 0%, #3498db ${percentage}%, #ddd ${percentage}%, #ddd 100%)`;
                }
            }

            // Prepare data structure: variable -> region -> value
            const variableData = {};
            allVariables.forEach(variable => {
                variableData[variable] = {};
                currentClustering.regions.forEach(region => {
                    variableData[variable][region] = null;
                });
            });

            // Fill data from currentYearlyData
            currentYearlyData.forEach(row => {
                if (variableData[row.data_type] && variableData[row.data_type][row.region] !== undefined) {
                    variableData[row.data_type][row.region] = row.value;
                }
            });

            // Calculate gap normalized for each variable
            const variableGaps = [];

            allVariables.forEach(variable => {
                const selectedValues = [];
                const nonSelectedValues = [];

                currentClustering.regions.forEach(region => {
                    const value = variableData[variable][region];
                    if (value !== null && value !== undefined) {
                        if (selectedRegionNames.includes(region)) {
                            selectedValues.push(value);
                        } else {
                            nonSelectedValues.push(value);
                        }
                    }
                });

                // If regions are selected, calculate gap between selected and non-selected
                if (selectedValues.length > 0 && nonSelectedValues.length > 0) {
                    // Calculate means
                    const meanSelected = selectedValues.reduce((a, b) => a + b, 0) / selectedValues.length;
                    const meanNonSelected = nonSelectedValues.reduce((a, b) => a + b, 0) / nonSelectedValues.length;

                    // Calculate standard deviation of all values
                    const allValues = [...selectedValues, ...nonSelectedValues];
                    const meanAll = allValues.reduce((a, b) => a + b, 0) / allValues.length;
                    const variance = allValues.reduce((sum, val) => sum + Math.pow(val - meanAll, 2), 0) / allValues.length;
                    const stdDev = Math.sqrt(variance);

                    // Normalized gap
                    const gap = stdDev > 0 ? Math.abs(meanSelected - meanNonSelected) / stdDev : 0;

                    variableGaps.push({
                        variable: variable,
                        gap: gap,
                        data: variableData[variable]
                    });
                } else if (selectedValues.length === 0 && nonSelectedValues.length > 0) {
                    // No selection yet - use coefficient of variation as diversity metric
                    const mean = nonSelectedValues.reduce((a, b) => a + b, 0) / nonSelectedValues.length;
                    const variance = nonSelectedValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / nonSelectedValues.length;
                    const stdDev = Math.sqrt(variance);
                    const coefficientOfVariation = mean !== 0 ? stdDev / Math.abs(mean) : stdDev;

                    variableGaps.push({
                        variable: variable,
                        gap: coefficientOfVariation,
                        data: variableData[variable]
                    });
                }
            });

            // Sort by gap descending and take top K
            variableGaps.sort((a, b) => b.gap - a.gap);

            let topKVariables;
            if (isManualTopKMode && manualSelectedVariables.length > 0) {
                // Use manually selected variables
                topKVariables = variableGaps.filter(v => manualSelectedVariables.includes(v.variable));
            } else {
                // Use automatic top K selection
                topKVariables = variableGaps.slice(0, topKValue);
            }

            if (topKVariables.length === 0) {
                tableHead.innerHTML = '<tr><th>No data available</th></tr>';
                tableBody.innerHTML = '';
                return;
            }

            // TRANSPOSED TABLE: Variables in columns, Clusters+Regions in rows
            // Build table header: Cluster/Region | Variable1 | Variable2 | ... | VariableK
            let headerHTML = '<tr><th class="col-selected-regions">Cluster / Region</th>';

            topKVariables.forEach(varObj => {
                const displayName = indicatorNames[varObj.variable] || varObj.variable;
                headerHTML += `<th>${displayName}</th>`;
            });

            headerHTML += '</tr>';
            tableHead.innerHTML = headerHTML;

            // Pre-calculate all values for each variable to determine min/max for color normalization
            const variableStats = {};
            topKVariables.forEach(varObj => {
                const variable = varObj.variable;
                const data = varObj.data;
                const allValues = [];

                // Collect all values for this variable (selected regions + cluster medians)
                selectedRegionNames.forEach(region => {
                    const val = data[region];
                    if (val !== null && val !== undefined) allValues.push(val);
                });

                // Also collect cluster median values
                uniqueClusters.forEach(clusterId => {
                    const clusterRegionsNonSelected = currentClustering.regions.filter((region, idx) =>
                        currentClustering.clusters[idx] === clusterId && !selectedRegionNames.includes(region)
                    );

                    let clusterValues = clusterRegionsNonSelected
                        .map(region => data[region])
                        .filter(v => v !== null && v !== undefined);

                    if (clusterValues.length === 0) {
                        const allClusterRegions = currentClustering.regions.filter((region, idx) =>
                            currentClustering.clusters[idx] === clusterId
                        );
                        clusterValues = allClusterRegions
                            .map(region => data[region])
                            .filter(v => v !== null && v !== undefined);
                    }

                    if (clusterValues.length > 0) {
                        clusterValues.sort((a, b) => a - b);
                        const mid = Math.floor(clusterValues.length / 2);
                        const median = clusterValues.length % 2 === 0
                            ? (clusterValues[mid - 1] + clusterValues[mid]) / 2
                            : clusterValues[mid];
                        allValues.push(median);
                    }
                });

                variableStats[variable] = {
                    min: Math.min(...allValues),
                    max: Math.max(...allValues),
                    range: Math.max(...allValues) - Math.min(...allValues)
                };
            });

            // Build table body: one row per selected region first, then one row per cluster median
            let bodyHTML = '';

            // First, add selected region rows
            selectedRegionNames.forEach(region => {
                bodyHTML += '<tr>';
                bodyHTML += `<td class="col-selected-regions" style="text-align: left; font-weight: bold;">${region}</td>`;

                topKVariables.forEach(varObj => {
                    const variable = varObj.variable;
                    const data = varObj.data;
                    const stats = variableStats[variable];
                    const value = data[region];

                    if (value !== null && value !== undefined) {
                        // Normalize using variable's column statistics
                        const normalized = stats.range > 0 ? (value - stats.min) / stats.range : 0.5;
                        const color = getHeatmapColor(normalized);
                        bodyHTML += `<td style="background-color: ${color};"><span class="topk-value-box">${value.toFixed(2)}</span></td>`;
                    } else {
                        bodyHTML += `<td style="background-color: #f0f0f0;"><span class=\"topk-value-box\">-</span></td>`;
                    }
                });

                bodyHTML += '</tr>';
            });

            // Then, add cluster median rows
            uniqueClusters.forEach(clusterId => {
                bodyHTML += '<tr>';
                bodyHTML += `<td class="col-selected-regions" style="text-align: left;">Cluster ${clusterId + 1}</td>`;

                topKVariables.forEach(varObj => {
                    const variable = varObj.variable;
                    const data = varObj.data;
                    const stats = variableStats[variable];

                    // Calculate cluster median
                    const clusterRegionsNonSelected = currentClustering.regions.filter((region, idx) =>
                        currentClustering.clusters[idx] === clusterId && !selectedRegionNames.includes(region)
                    );

                    let clusterValues = clusterRegionsNonSelected
                        .map(region => data[region])
                        .filter(v => v !== null && v !== undefined);

                    if (clusterValues.length === 0) {
                        const allClusterRegions = currentClustering.regions.filter((region, idx) =>
                            currentClustering.clusters[idx] === clusterId
                        );
                        clusterValues = allClusterRegions
                            .map(region => data[region])
                            .filter(v => v !== null && v !== undefined);
                    }

                    if (clusterValues.length > 0) {
                        clusterValues.sort((a, b) => a - b);
                        const mid = Math.floor(clusterValues.length / 2);
                        const median = clusterValues.length % 2 === 0
                            ? (clusterValues[mid - 1] + clusterValues[mid]) / 2
                            : clusterValues[mid];

                        // Normalize using variable's column statistics
                        const normalized = stats.range > 0 ? (median - stats.min) / stats.range : 0.5;
                        const color = getHeatmapColor(normalized);
                        bodyHTML += `<td style="background-color: ${color};"><span class="topk-value-box">${median.toFixed(2)}</span></td>`;
                    } else {
                        bodyHTML += `<td style="background-color: #f0f0f0;"><span class=\"topk-value-box\">-</span></td>`;
                    }
                });

                bodyHTML += '</tr>';
            });

            tableBody.innerHTML = bodyHTML;
        }

        function getHeatmapColor(normalized) {
            // Color scale with 9 distinct orange colors from light to dark
            const colors = [
                '#fff5eb',
                '#fee6ce',
                '#fdd0a2',
                '#fdae6b',
                '#fd8d3c',
                '#f16913',
                '#d94801',
                '#a63603',
                '#7f2704'
            ];

            // Map normalized (0-1) to one of the 9 colors
            const index = Math.min(Math.floor(normalized * colors.length), colors.length - 1);
            return colors[index];
        }

        // Resize handler
        window.addEventListener('resize', () => {
            map.invalidateSize();
        });

        // Load Italy regions GeoJSON
        async function loadRegionsGeoJSON() {
            try {
                // Using public GeoJSON for Italian regions
                const response = await fetch('https://raw.githubusercontent.com/openpolis/geojson-italy/master/geojson/limits_IT_regions.geojson');
                regionGeoJson = await response.json();
                console.log('GeoJSON loaded:', regionGeoJson.features.length, 'regions');

                // Initialize GeoJSON layer WITHOUT default style to avoid gray borders
                // Styles will be applied by updateMapStyles() after clustering data loads
                geoJsonLayer = L.geoJSON(regionGeoJson, {
                    onEachFeature: onEachFeature,
                    renderer: L.canvas(),
                    style: function() {
                        // Temporary invisible style until clustering data loads
                        return {
                            fillColor: 'transparent',
                            fillOpacity: 0,
                            weight: 0,
                            opacity: 0
                        };
                    }
                }).addTo(map);

            } catch (error) {
                console.error('Error loading GeoJSON:', error);
                alert('Failed to load map regions. Using fallback markers.');
            }
        }

        function defaultStyle(feature) {
            return {
                fillColor: 'transparent',
                weight: 2,
                opacity: 1,
                color: '#999',
                fillOpacity: 0.7
            };
        }

        function onEachFeature(feature, layer) {
            layer.on({
                mouseover: highlightFeature,
                mouseout: resetHighlight,
                click: selectRegionFromMap
            });
        }

        function highlightFeature(e) {
            const layer = e.target;
            const regionName = getRegionNameFromFeature(layer.feature);

            if (!selectedRegionNames.includes(regionName)) {
                layer.setStyle({
                    weight: 4,
                    opacity: 1
                });
            }

            // Show tooltip
            const props = layer.feature.properties;
            const name = getRegionNameFromFeature(layer.feature);
            let tooltipContent = `<b>${name}</b>`;

            if (currentClustering) {
                const regionIdx = currentClustering.regions.indexOf(name);
                if (regionIdx >= 0) {
                    const clusterId = currentClustering.clusters[regionIdx];
                    tooltipContent += `<br>Cluster: ${clusterId + 1}`;
                }
            }

            if (selectedVariable && selectedVariable !== 'none' && currentYearlyData) {
                const value = getRegionVariableValue(name, selectedVariable);
                if (value !== null) {
                    const displayName = indicatorNames[selectedVariable] || selectedVariable;
                    tooltipContent += `<br>${displayName}: ${value.toFixed(2)}`;
                }
            }

            layer.bindTooltip(tooltipContent).openTooltip();
        }

        function resetHighlight(e) {
            const layer = e.target;
            const regionName = getRegionNameFromFeature(layer.feature);

            // Don't use resetStyle - it causes gray color
            // Instead, reapply correct styles
            if (!selectedRegionNames.includes(regionName)) {
                // Find the region in clustering data and reapply its style
                if (currentClustering) {
                    const regionIdx = currentClustering.regions.indexOf(regionName);
                    if (regionIdx >= 0) {
                        const clusterId = currentClustering.clusters[regionIdx];
                        const clusterColor = clusterColors[clusterId % clusterColors.length];

                        // Default: use cluster color as fill
                        let fillColor = clusterColor;
                        let fillOpacity = 0.5;

                        // If a variable is selected, override with variable color
                        if (selectedVariable && selectedVariable !== 'none' && currentYearlyData) {
                            const value = getRegionVariableValue(regionName, selectedVariable);
                            if (value !== null && globalScales[selectedVariable]) {
                                const scale = globalScales[selectedVariable];
                                const range = scale.max - scale.min;
                                const normalized = range > 0 ? (value - scale.min) / range : 0.5;
                                fillColor = getHeatmapColor(normalized);
                                fillOpacity = 0.7;
                            }
                        }

                        layer.setStyle({
                            fillColor: fillColor,
                            fillOpacity: fillOpacity,
                            weight: 3,
                            opacity: 1,
                            color: clusterColor
                        });
                    }
                }
            }

            layer.closeTooltip();
        }

        function selectRegionFromMap(e) {
            const layer = e.target;
            const regionName = getRegionNameFromFeature(layer.feature);

            // Toggle selection
            const index = selectedRegionNames.indexOf(regionName);
            if (index >= 0) {
                selectedRegionNames.splice(index, 1);
            } else {
                selectedRegionNames.push(regionName);
            }

            console.log('Selected from map:', regionName);

            // Update both visualizations
            updateMapStyles();
            updateSelectionHighlight();
        }

        function getRegionNameFromFeature(feature) {
            // GeoJSON properties may vary, try common field names
            const props = feature.properties;
            return props.reg_name || props.name || props.NOME_REG || props.NAME_1 || '';
        }

        function getRegionVariableValue(regionName, variable) {
            if (!currentYearlyData) return null;

            const row = currentYearlyData.find(r => r.region === regionName && r.data_type === variable);
            return row ? row.value : null;
        }

        // Calculate global scales for all variables (0 to max across all years)
        // This is used only in non-temporal mode, in temporal mode we preload all years
        async function calculateGlobalScales() {
            try {
                console.log('Computing global scales from current data (non-temporal mode)...');

                if (!currentYearlyData) return;

                const variables = [...new Set(currentYearlyData.map(row => row.data_type))];

                // For each variable, set min to 0 and use current max
                variables.forEach(variable => {
                    const values = currentYearlyData
                        .filter(row => row.data_type === variable)
                        .map(row => row.value)
                        .filter(v => v !== null && v !== undefined);

                    if (values.length > 0) {
                        const currentMin = Math.min(...values);
                        const currentMax = Math.max(...values);
                        let pad = (currentMax - currentMin) * 0.05; // 5% padding
                        if (pad === 0) pad = Math.abs(currentMax) * 0.05 || 1;

                        globalScales[variable] = {
                            min: currentMin - pad,
                            max: currentMax + pad
                        };
                    }
                });

                globalScalesCalculated = true;
                console.log('Global scales computed for', Object.keys(globalScales).length, 'variables (min=0, max=current)');
            } catch (error) {
                console.error('Error computing global scales:', error);
            }
        }

        function updateMapVariable() {
            selectedVariable = document.getElementById('map-variable-select').value;
            console.log('Map variable changed to:', selectedVariable);
            updateMapStyles();
        }

        function populateVariableDropdown() {
            if (!currentYearlyData) return;

            const select = document.getElementById('map-variable-select');
            const variables = [...new Set(currentYearlyData.map(row => row.data_type))].sort();

            // Keep "None" option and add all variables
            const currentValue = select.value;
            select.innerHTML = '<option value="none">None</option>';

            variables.forEach(variable => {
                const displayName = indicatorNames[variable] || variable;
                const option = document.createElement('option');
                option.value = variable;
                option.textContent = displayName;
                select.appendChild(option);
            });

            // Restore previous selection if still valid
            if (currentValue && currentValue !== 'none' && variables.includes(currentValue)) {
                select.value = currentValue;
            }

            // Also populate bubble chart dropdowns
            populateBubbleDropdowns(variables);
        }

        /**
         * UPDATED: Populates bubble chart dropdowns and adds "None" option for Size
         */
        function populateBubbleDropdowns(variables) {
    console.log('populateBubbleDropdowns called with', variables.length, 'variables');
    const xSelect = document.getElementById('bubble-x-select');
    const ySelect = document.getElementById('bubble-y-select');
    const sizeSelect = document.getElementById('bubble-size-select');

    if (!xSelect || !ySelect || !sizeSelect) {
        console.error('Dropdown elements not found!');
        return;
    }

    // Store current values
    const currentX = xSelect.value || bubbleXVar;
    const currentY = ySelect.value || bubbleYVar;
    const currentSize = sizeSelect.value || bubbleSizeVar;

    // 1. Populate X and Y (Standard)
    [xSelect, ySelect].forEach(select => {
        select.innerHTML = '';
        variables.forEach(variable => {
            const displayName = indicatorNames[variable] || variable;
            const option = document.createElement('option');
            option.value = variable;
            option.textContent = displayName;
            select.appendChild(option);
        });
    });

    // 2. Populate Size (Add "None" option)
    sizeSelect.innerHTML = '';

    // Add "None" Option
    const noneOption = document.createElement('option');
    noneOption.value = 'none';
    noneOption.textContent = 'None';
    sizeSelect.appendChild(noneOption);

    variables.forEach(variable => {
        const displayName = indicatorNames[variable] || variable;
        const option = document.createElement('option');
        option.value = variable;
        option.textContent = displayName;
        sizeSelect.appendChild(option);
    });

    // Set default or restore previous values
    xSelect.value = variables.includes(currentX) ? currentX : (variables.includes('BIRTHRATE') ? 'BIRTHRATE' : variables[0]);
    ySelect.value = variables.includes(currentY) ? currentY : (variables.includes('LIFEEXP0T') ? 'LIFEEXP0T' : variables[0]);

    // Handle Size selection specifically
    if (currentSize === 'none') {
        sizeSelect.value = 'none';
    } else {
        sizeSelect.value = variables.includes(currentSize) ? currentSize : (variables.includes('DEATHRATE') ? 'DEATHRATE' : variables[0]);
    }

    // Update state variables
    bubbleXVar = xSelect.value;
    bubbleYVar = ySelect.value;
    bubbleSizeVar = sizeSelect.value;
}

        // Initial load - IMPORTANT: Load GeoJSON FIRST, then clustering data
        // This ensures the map regions exist before we try to color them
        async function initializeDashboard() {
            console.log('Initializing dashboard...');
            await loadRegionsGeoJSON();
            console.log('GeoJSON loaded, now loading clustering data...');
            await loadClusteringData();
            // Ensure year display visibility is correct on initial load (overview by default)
            setYearDisplayVisibility();
            console.log('Dashboard initialized!');

            // Setup manual mode event listeners
            setupManualModeListeners();
        }

        function setupManualModeListeners() {
            // Checkbox toggle
            const checkbox = document.getElementById('manual-mode-toggle');
            if (checkbox) {
                checkbox.addEventListener('change', toggleManualMode);
                console.log('‚úÖ Manual checkbox listener attached');
            }
        }

        initializeDashboard();
    </script>
</body>
</html>