<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Italian Demographics - Complete Analytics Suite</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

    <style>
        :root {
            --primary-bg: #f4f6f8;
            --card-bg: #ffffff;
            --header-bg: #2c3e50;
            --text-main: #333;
            --accent: #3498db;
            --border-radius: 8px;
            --pcp-line: rgba(52, 152, 219, 0.3);
            --pcp-selected: #e74c3c;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            margin: 0; background-color: var(--primary-bg);
            height: 100vh; display: flex; flex-direction: column; overflow: hidden;
        }

        header {
            background-color: var(--header-bg);
            color: white; padding: 0 15px; height: 40px;
            display: flex; align-items: center; justify-content: space-between;
            flex-shrink: 0;
        }

        .dashboard-container {
            display: grid;
            grid-template-columns: 42% 58%;
            gap: 8px; padding: 8px;
            height: calc(100vh - 40px);
            box-sizing: border-box;
        }

        .col { display: flex; flex-direction: column; gap: 8px; height: 100%; min-height: 0; }

        .card {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 10px; display: flex; flex-direction: column;
            min-height: 0;
        }

        .card-header {
            font-size: 0.7rem; font-weight: 700; color: var(--header-bg);
            border-bottom: 1px solid #eee; margin-bottom: 5px; padding-bottom: 3px;
            text-transform: uppercase;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Layout Ratios */
        .map-wrapper { flex: 1.5; }
        .cluster-wrapper { flex: 1; }
        .pcp-wrapper { flex: 1; }
        .bubble-wrapper { flex: 1; }
        .stats-wrapper { flex: 1.2; overflow: hidden; }

        .chart-container { flex-grow: 1; position: relative; width: 100%; min-height: 0; }
        
        /* Controls */
        .cluster-controls {
            display: flex;
            gap: 6px;
            align-items: center;
            font-size: 0.65rem;
        }

        .mini-select {
            padding: 2px 4px;
            font-size: 0.65rem;
            border: 1px solid #ddd;
            border-radius: 3px;
            background: white;
        }

        .btn-mini {
            padding: 2px 6px;
            font-size: 0.7rem;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .btn-mini:hover {
            background: #2980b9;
        }

        .k-display {
            font-size: 0.65rem;
            color: #7f8c8d;
            font-weight: normal;
        }

        /* Temporal controls */
        .temporal-controls {
            background: rgba(240, 245, 250, 0.98);
            border-radius: 4px;
            padding: 5px 8px;
            margin-bottom: 5px;
            border: 1px solid #e0e0e0;
            display: none;
        }

        .temporal-controls.active {
            display: block;
        }

        .timeline-slider {
            width: 100%;
            margin: 5px 0;
        }

        .playback-controls {
            display: flex;
            gap: 5px;
            align-items: center;
            font-size: 0.7rem;
        }

        .year-display {
            font-weight: bold;
            font-size: 0.9rem;
            color: var(--header-bg);
        }

        /* Loading overlay */
        .loading-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            color: #7f8c8d;
            z-index: 100;
        }

        .loading-overlay.active {
            display: flex;
        }
        
        /* Table Styling per Schizzo */
        .table-scroll { overflow-y: auto; flex-grow: 1; border: 1px solid #f0f0f0; }
        table { width: 100%; border-collapse: collapse; font-size: 0.75rem; }
        th { background: #f8f9fa; border: 1px solid #dee2e6; padding: 6px; position: sticky; top: 0; }
        td { border: 1px solid #eee; padding: 6px; text-align: center; }
        
        .col-selected-regions { background: #ebf5fb; font-weight: bold; width: 110px; text-align: left; }
        
        /* K Slider Styling */
        .k-slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 5px;
        }
        
        .k-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 120px;
            height: 4px;
            background: linear-gradient(to right, #3498db 0%, #3498db 50%, #ddd 50%, #ddd 100%);
            border-radius: 2px;
            outline: none;
            opacity: 0.9;
            transition: opacity 0.2s;
        }
        
        .k-slider:hover {
            opacity: 1;
        }
        
        .k-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #2c3e50;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .k-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #2c3e50;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .k-value-display {
            font-size: 0.7rem;
            font-weight: bold;
            color: #2c3e50;
            min-width: 20px;
            text-align: center;
        }
        
        .pcp-svg { width: 100%; height: 100%; overflow: hidden; cursor: grab; }
        .pcp-svg:active { cursor: grabbing; }
        .pcp-axis { stroke: #ddd; stroke-width: 1; }
        .axis-label { fill: #999; font-size: 8px; text-anchor: middle; font-weight: bold; }
        .pcp-axis-label-rotated { fill: #555; font-size: 10px; text-anchor: start; font-weight: 600; }
        .pcp-path { fill: none; stroke-width: 1.2; }

        #italyMap { width: 100%; height: 100%; border-radius: 4px; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
        .leaflet-container { user-select: none; -webkit-user-select: none; }
        #clusterChart { cursor: crosshair; }
        .btn-update { background: var(--accent); color: white; border: none; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 0.75rem; }
    </style>
</head>
<body>

    <header>
        <div style="font-weight:600; font-size: 0.9rem;">Italian Demographics Dashboard</div>
        <button class="btn-update" onclick="loadClusteringData()">Refresh Data</button>
    </header>

    <div class="dashboard-container">
        <div class="col">
            <div class="card map-wrapper">
                <div class="card-header">
                    <span>Geospatial Distribution</span>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <label style="font-size: 0.65rem; font-weight: normal;">Variable:</label>
                        <select id="map-variable-select" class="mini-select" onchange="updateMapVariable()">
                            <option value="none" selected>None</option>
                        </select>
                    </div>
                </div>
                <div id="italyMap"></div>
            </div>
            <div class="card cluster-wrapper">
                <div class="card-header">
                    <span> Dimensionality Reduction (based on PCA and K-Means) <span class="k-display" id="k-display"></span></span>
                    <div class="cluster-controls">
                        <label style="font-size: 0.65rem;">K:</label>
                        <select id="k-mode-select" class="mini-select" onchange="loadClusteringData()">
                            <option value="auto" selected>Auto</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                            <option value="6">6</option>
                            <option value="7">7</option>
                            <option value="8">8</option>
                        </select>
                        <label style="font-size: 0.65rem; margin-left: 8px;">
                            <input type="checkbox" id="temporal-toggle" onchange="toggleTemporal()">
                            Temporal Mode
                        </label>
                    </div>
                </div>
                <div id="temporal-controls" class="temporal-controls">
                    <div class="playback-controls">
                        <button class="btn-mini" onclick="playAnimation()">▶ Play</button>
                        <button class="btn-mini" onclick="pauseAnimation()">⏸ Pause</button>
                        <button class="btn-mini" onclick="resetAnimation()">↺ Reset</button>
                        <select id="speed-select" class="mini-select">
                            <option value="6000">Slow</option>
                            <option value="3000" selected>Normal</option>
                            <option value="1200">Fast</option>
                            <option value="400">Very Fast</option>
                        </select>
                        <span class="year-display" id="year-display">2022</span>
                    </div>
                    <input type="range" id="timeline-slider" class="timeline-slider" 
                           min="0" max="100" value="0" oninput="onTimelineChange()">
                </div>
                <div class="chart-container">
                    <canvas id="clusterChart"></canvas>
                    <div id="cluster-loading" class="loading-overlay">
                        <span>Loading clustering data...</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="col">
            <div class="card pcp-wrapper">
                <div class="card-header">
                    <span>Multivariate Profile (PCP)</span>
                    <div style="display: flex; gap: 4px;">
                        <button class="btn-mini" onclick="zoomPCP(1.2)" title="Zoom In">+</button>
                        <button class="btn-mini" onclick="zoomPCP(0.8)" title="Zoom Out">−</button>
                        <button class="btn-mini" onclick="resetPCPZoom()" title="Reset Zoom">↺</button>
                    </div>
                </div>
                <div class="chart-container"><svg id="pcpSvg" class="pcp-svg"></svg></div>
            </div>

            <div class="card bubble-wrapper">
                <div class="card-header">
                    <span>Demographics Analysis </span>
                    <div style="display: flex; gap: 5px; align-items: center;">
                        <label style="font-size: 0.65rem; font-weight: normal;">X:</label>
                        <select id="bubble-x-select" class="mini-select" onchange="onBubbleVariableChange()"></select>
                        <label style="font-size: 0.65rem; font-weight: normal;">Y:</label>
                        <select id="bubble-y-select" class="mini-select" onchange="onBubbleVariableChange()"></select>
                        <label style="font-size: 0.65rem; font-weight: normal;">Size:</label>
                        <select id="bubble-size-select" class="mini-select" onchange="onBubbleVariableChange()"></select>
                        <button class="btn-mini" onclick="resetBubbleZoom()" title="Reset Zoom">⟲</button>
                    </div>
                </div>
                <div class="chart-container"><canvas id="bubbleChart"></canvas></div>
            </div>

            <div class="card stats-wrapper">
                <div class="card-header">
                    <span>Top K Diverse Variables</span>
                    <div class="k-slider-container">
                        <label style="font-size: 0.65rem; font-weight: normal;">K:</label>
                        <input type="range" id="k-slider" class="k-slider" 
                               min="1" max="32" value="15" 
                               oninput="updateTopKValue()">
                        <span id="k-value-display" class="k-value-display">15</span>
                    </div>
                </div>
                <div class="table-scroll">
                    <table>
                        <thead id="tableHead"></thead>
                        <tbody id="tableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Server configuration
        const SERVER_BASE = 'http://127.0.0.1:5000';
        
        // Region coordinates for map
        const regionCoords = {
            "Abruzzo": [42.35, 13.39],
            "Basilicata": [40.63, 15.80],
            "Calabria": [38.91, 16.59],
            "Campania": [40.83, 14.25],
            "Emilia-Romagna": [44.49, 11.34],
            "Friuli-Venezia Giulia": [46.06, 13.24],
            "Lazio": [41.89, 12.51],
            "Liguria": [44.41, 8.95],
            "Lombardia": [45.46, 9.19],
            "Marche": [43.62, 13.51],
            "Molise": [41.67, 14.60],
            "Piemonte": [45.07, 7.69],
            "Puglia": [41.13, 16.87],
            "Sardegna": [39.22, 9.12],
            "Sicilia": [38.12, 13.36],
            "Toscana": [43.77, 11.25],
            "Trentino-Alto Adige": [46.07, 11.12],
            "Umbria": [43.11, 12.39],
            "Valle d'Aosta": [45.74, 7.43],
            "Veneto": [45.44, 12.32]
        };

        // Map setup
        const map = L.map('italyMap', {
            center: [42.5, 12.5],
            zoom: 5,
            zoomControl: false,
            dragging: false,
            scrollWheelZoom: false,
            doubleClickZoom: false,
            boxZoom: false,
            keyboard: false,
            touchZoom: false
        });
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png').addTo(map);
        const mapLayer = L.layerGroup().addTo(map);

        // Cluster colors (8 colors for max 8 clusters)
        const clusterColors = [
            '#e41a1c', '#377eb8', '#4daf4a', '#984ea3',
            '#ff7f00', '#ffff33', '#a65628', '#f781bf'
        ];

        // State variables
        let currentDataSet = [];
        let currentClustering = null;
        let selectedRegionNames = [];
        let isDrawing = false;
        let brushStart = null;
        let brushEnd = null;
        let hasMoved = false;
        let currentYearlyData = null;
        let commonIndicators = ['BIRTHRATE', 'DEATHRATE', 'LIFEEXP0T', 'DEPENDRATE', 'MARRATE'];
        let topKValue = 15; // Default K value for top variables
        let orderedPCPVariables = [];
        
        // PCP Zoom and Pan state
        let pcpZoomLevel = 1;
        let pcpPanX = 0;
        let pcpPanY = 0;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0; // Ordered list of top K variables for PCP axes
        let indicatorNames = {}; // Map DATA_TYPE -> readable name
        let selectedVariable = null; // Currently selected variable for map coloring
        let globalScales = {}; // Global min-max for each variable across all years
        let geoJsonLayer = null; // GeoJSON layer for regions
        let regionGeoJson = null; // GeoJSON data
        
        // ============================================
        // BUBBLE CHART STATE MANAGEMENT
        // ============================================
        
        // Variable configuration for axes and bubble size
        let bubbleXVar = 'BIRTHRATE';
        let bubbleYVar = 'LIFEEXP0T';
        let bubbleSizeVar = 'DEATHRATE';
        
        // Trail tracking for temporal mode
        let bubbleTrails = {}; // region -> array of {x, y, size, year}
        let clickedBubbleRegions = []; // Regions selected for trail visualization
        
        // Hover state for interactive crosshair
        let bubbleHoverState = {
            active: false,
            region: null,
            position: { x: 0, y: 0 },
            values: { x: 0, y: 0, size: 0 }
        };
        
        // Animation variables
        let timeseriesData = null;
        let animationInterval = null;
        let currentTimeIndex = 0;
        let isAnimationPlaying = false;

        // Brush selection plugin
        const brushPlugin = {
            id: 'brushPlugin',
            afterDatasetsDraw: (chart) => {
                if (brushStart && brushEnd) {
                    const ctx = chart.ctx;
                    ctx.save();
                    ctx.fillStyle = 'rgba(52, 152, 219, 0.2)';
                    ctx.strokeStyle = 'rgba(52, 152, 219, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);

                    const x = Math.min(brushStart.x, brushEnd.x);
                    const y = Math.min(brushStart.y, brushEnd.y);
                    const w = Math.abs(brushEnd.x - brushStart.x);
                    const h = Math.abs(brushEnd.y - brushStart.y);
                    
                    ctx.fillRect(x, y, w, h);
                    ctx.strokeRect(x, y, w, h);
                    ctx.restore();
                }
            }
        };

        // Chart setup
        const clusterChart = new Chart(document.getElementById('clusterChart'), {
            type: 'scatter',
            data: { datasets: [] },
            options: { 
                responsive: true, 
                maintainAspectRatio: false,
                animation: {
                    duration: 0 // Disable Chart.js animation to have smooth manual interpolation
                },
                plugins: { 
                    legend: { 
                        display: true,
                        position: 'top',
                        labels: {
                            font: { size: 10 },
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const region = context.dataset.regionNames[context.dataIndex];
                                const cluster = context.dataset.label;
                                return `${region} - ${cluster}`;
                            }
                        }
                    }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'Component 1', font: { size: 10 } },
                        min: -10,
                        max: 10
                    },
                    y: { 
                        title: { display: true, text: 'Component 2', font: { size: 10 } },
                        min: -10,
                        max: 10
                    }
                }
            },
            plugins: [brushPlugin]
        });

        // ============================================
        // BUBBLE CHART PLUGINS
        // ============================================
        
        /**
         * Plugin: Year Watermark - Displays current year in temporal mode
         */
        const bubbleYearWatermarkPlugin = {
            id: 'bubbleYearWatermark',
            beforeDatasetsDraw: (chart) => {
                if (!timeseriesData || currentTimeIndex >= timeseriesData.length) return;
                
                const ctx = chart.ctx;
                const chartArea = chart.chartArea;
                const centerX = (chartArea.left + chartArea.right) / 2;
                const centerY = (chartArea.top + chartArea.bottom) / 2;
                const year = timeseriesData[currentTimeIndex].year;
                
                ctx.save();
                ctx.font = 'bold 90px Segoe UI';
                ctx.fillStyle = 'rgba(200, 200, 200, 0.12)';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(year, centerX, centerY);
                ctx.restore();
            }
        };
        
        /**
         * Plugin: Interactive Crosshair - Shows crosshair lines and axis labels
         */
        const bubbleCrosshairPlugin = {
            id: 'bubbleCrosshair',
            afterDatasetsDraw: (chart) => {
                if (!bubbleHoverState.active) return;
                
                const ctx = chart.ctx;
                const chartArea = chart.chartArea;
                const { x, y } = bubbleHoverState.position;
                const { x: xVal, y: yVal } = bubbleHoverState.values;
                
                ctx.save();
                
                // Draw crosshair lines
                ctx.setLineDash([6, 4]);
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.6)';
                ctx.lineWidth = 1.5;
                
                // Vertical line
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, chartArea.bottom);
                ctx.stroke();
                
                // Horizontal line
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(chartArea.left, y);
                ctx.stroke();
                
                // Draw axis labels
                ctx.setLineDash([]);
                ctx.font = 'bold 11px Segoe UI';
                
                // X-axis label
                const xText = xVal.toFixed(2);
                const xTextWidth = ctx.measureText(xText).width;
                const xLabelX = Math.max(chartArea.left + 5, Math.min(x - xTextWidth / 2, chartArea.right - xTextWidth - 5));
                const xLabelY = chartArea.bottom + 18;
                
                drawLabelBox(ctx, xLabelX, xLabelY, xText, '#3498db');
                
                // Y-axis label
                const yText = yVal.toFixed(2);
                const yTextWidth = ctx.measureText(yText).width;
                const yLabelX = chartArea.left - yTextWidth - 12;
                const yLabelY = y + 5;
                
                drawLabelBox(ctx, yLabelX, yLabelY, yText, '#e74c3c');
                
                ctx.restore();
            }
        };
        
        /**
         * Plugin: Enhanced Tooltip - Shows detailed bubble information
         */
        const bubbleTooltipPlugin = {
            id: 'bubbleTooltip',
            afterDatasetsDraw: (chart) => {
                if (!bubbleHoverState.active || !bubbleHoverState.region) return;
                
                const ctx = chart.ctx;
                const chartArea = chart.chartArea;
                const { x, y } = bubbleHoverState.position;
                const { x: xVal, y: yVal, size: sizeVal } = bubbleHoverState.values;
                const region = bubbleHoverState.region;
                
                // Tooltip content
                const xName = indicatorNames[bubbleXVar] || bubbleXVar;
                const yName = indicatorNames[bubbleYVar] || bubbleYVar;
                const sizeName = indicatorNames[bubbleSizeVar] || bubbleSizeVar;
                
                const lines = [
                    { label: 'Region', value: region, bold: true },
                    { label: xName, value: xVal.toFixed(2) },
                    { label: yName, value: yVal.toFixed(2) },
                    { label: sizeName, value: sizeVal.toFixed(2), color: '#ff7f00' }
                ];
                
                // Calculate tooltip dimensions
                ctx.font = '11px Segoe UI';
                const lineHeight = 18;
                const padding = 10;
                const maxLabelWidth = Math.max(...lines.map(l => ctx.measureText(l.label + ':').width));
                const maxValueWidth = Math.max(...lines.map(l => ctx.measureText(l.value).width));
                const tooltipWidth = maxLabelWidth + maxValueWidth + padding * 3;
                const tooltipHeight = lines.length * lineHeight + padding * 2;
                
                // Position tooltip (avoid edges)
                let tooltipX = x + 15;
                let tooltipY = y - tooltipHeight / 2;
                
                if (tooltipX + tooltipWidth > chartArea.right) {
                    tooltipX = x - tooltipWidth - 15;
                }
                if (tooltipY < chartArea.top) {
                    tooltipY = chartArea.top;
                }
                if (tooltipY + tooltipHeight > chartArea.bottom) {
                    tooltipY = chartArea.bottom - tooltipHeight;
                }
                
                ctx.save();
                
                // Draw tooltip background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 1;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                
                roundRect(ctx, tooltipX, tooltipY, tooltipWidth, tooltipHeight, 6);
                ctx.fill();
                ctx.shadowColor = 'transparent';
                ctx.stroke();
                
                // Draw tooltip content
                let currentY = tooltipY + padding + 12;
                lines.forEach(line => {
                    // Label
                    ctx.font = line.bold ? 'bold 12px Segoe UI' : '11px Segoe UI';
                    ctx.fillStyle = '#555';
                    ctx.textAlign = 'left';
                    ctx.fillText(line.label + ':', tooltipX + padding, currentY);
                    
                    // Value
                    ctx.font = line.bold ? 'bold 12px Segoe UI' : 'bold 11px Segoe UI';
                    ctx.fillStyle = line.color || '#2c3e50';
                    ctx.textAlign = 'right';
                    ctx.fillText(line.value, tooltipX + tooltipWidth - padding, currentY);
                    
                    currentY += lineHeight;
                });
                
                ctx.restore();
            }
        };
        
        // ============================================
        // BUBBLE CHART HELPER FUNCTIONS
        // ============================================
        
        /**
         * Draw a label box with background and border
         */
        function drawLabelBox(ctx, x, y, text, accentColor = '#3498db') {
            const textWidth = ctx.measureText(text).width;
            const boxPadding = 5;
            const boxWidth = textWidth + boxPadding * 2;
            const boxHeight = 18;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(x - boxPadding, y - 13, boxWidth, boxHeight);
            
            ctx.strokeStyle = accentColor;
            ctx.lineWidth = 2;
            ctx.strokeRect(x - boxPadding, y - 13, boxWidth, boxHeight);
            
            ctx.fillStyle = '#2c3e50';
            ctx.fillText(text, x, y);
        }
        
        /**
         * Draw rounded rectangle
         */
        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }
        
        /**
         * Convert hex color to rgba
         */
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        /**
         * Calculate bubble radius
         */
        function calculateBubbleRadius(sizeValue, minSize = 8, maxSize = 25) {
            return Math.sqrt(Math.abs(sizeValue)) * 2 + minSize;
        }
        
        /**
         * Get region data for bubble chart
         */
        function getRegionBubbleData(regionName) {
            const values = {};
            
            if (!currentYearlyData) return null;
            
            currentYearlyData.forEach(row => {
                if (row.region === regionName) {
                    values[row.data_type] = row.value;
                }
            });
            
            const xVal = values[bubbleXVar];
            const yVal = values[bubbleYVar];
            const sizeVal = values[bubbleSizeVar];
            
            if (xVal === undefined || yVal === undefined || sizeVal === undefined) {
                return null;
            }
            
            return { x: xVal, y: yVal, size: sizeVal, allValues: values };
        }
        
        /**
         * Get bubble color based on size value (heatmap)
         */
        function getBubbleColor(sizeValue) {
            const sizeScale = globalScales[bubbleSizeVar];
            if (!sizeScale || sizeScale.max === sizeScale.min) {
                return '#fdae6b';
            }
            
            const normalized = (sizeValue - sizeScale.min) / (sizeScale.max - sizeScale.min);
            return getHeatmapColor(normalized);
        }
        
        /**
         * Reset bubble zoom
         */
        function resetBubbleZoom() {
            bubbleChart.resetZoom();
            bubbleHoverState.active = false;
            bubbleChart.update('none');
        }
        
        // ============================================
        // BUBBLE CHART EVENT HANDLERS
        // ============================================
        
        /**
         * Handle bubble click events
         */
        function handleBubbleClick(event, elements) {
            const isTemporalMode = document.getElementById('temporal-toggle')?.checked;
            
            if (elements.length > 0) {
                const datasetIndex = elements[0].datasetIndex;
                const dataset = bubbleChart.data.datasets[datasetIndex];
                
                if (!dataset.regionName) return;
                
                const region = dataset.regionName;
                
                if (isTemporalMode) {
                    const index = clickedBubbleRegions.indexOf(region);
                    if (index >= 0) {
                        clickedBubbleRegions.splice(index, 1);
                        console.log('Trail hidden:', region);
                    } else {
                        clickedBubbleRegions.push(region);
                        console.log('Trail shown:', region);
                    }
                    updateBubbleChart();
                } else {
                    console.log('Clicked region:', region);
                }
            } else {
                if (clickedBubbleRegions.length > 0) {
                    clickedBubbleRegions = [];
                    console.log('All trails cleared');
                    updateBubbleChart();
                }
            }
        }
        
        /**
         * Handle bubble hover events
         */
        function handleBubbleHover(event, elements) {
            const canvas = event.native.target;
            
            if (elements.length > 0) {
                const element = elements[0];
                const datasetIndex = element.datasetIndex;
                const dataIndex = element.index;
                const dataset = bubbleChart.data.datasets[datasetIndex];
                const dataPoint = dataset.data[dataIndex];
                
                if (!dataPoint || !dataset.regionName) {
                    canvas.style.cursor = 'default';
                    bubbleHoverState.active = false;
                    bubbleChart.update('none');
                    return;
                }
                
                canvas.style.cursor = 'pointer';
                
                const xScale = bubbleChart.scales.x;
                const yScale = bubbleChart.scales.y;
                
                bubbleHoverState.active = true;
                bubbleHoverState.region = dataset.regionName;
                bubbleHoverState.position = {
                    x: xScale.getPixelForValue(dataPoint.x),
                    y: yScale.getPixelForValue(dataPoint.y)
                };
                bubbleHoverState.values = {
                    x: dataPoint.x,
                    y: dataPoint.y,
                    size: getRegionBubbleData(dataset.regionName)?.size || 0
                };
                
                bubbleChart.update('none');
            } else {
                canvas.style.cursor = 'default';
                bubbleHoverState.active = false;
                bubbleChart.update('none');
            }
        }

        // ============================================
        // BUBBLE CHART CONFIGURATION
        // ============================================
        
        const bubbleChart = new Chart(document.getElementById('bubbleChart'), {
            type: 'bubble',
            data: { datasets: [] },
            options: { 
                responsive: true, 
                maintainAspectRatio: false,
                animation: { duration: 0 },
                scales: { 
                    x: { 
                        title: { 
                            display: true, 
                            text: 'Birth Rate', 
                            font: { size: 11, weight: '600' },
                            color: '#2c3e50'
                        },
                        grid: { color: 'rgba(0, 0, 0, 0.05)' },
                        ticks: { font: { size: 10 } },
                        min: 0,
                        max: 20
                    }, 
                    y: { 
                        title: { 
                            display: true, 
                            text: 'Life Expectancy', 
                            font: { size: 11, weight: '600' },
                            color: '#2c3e50'
                        },
                        grid: { color: 'rgba(0, 0, 0, 0.05)' },
                        ticks: { font: { size: 10 } },
                        min: 70,
                        max: 90
                    } 
                },
                plugins: { 
                    legend: { display: false },
                    tooltip: { enabled: false },
                    zoom: {
                        pan: {
                            enabled: true,
                            mode: 'xy',
                            modifierKey: null
                        },
                        zoom: {
                            wheel: {
                                enabled: true,
                                speed: 0.1,
                                modifierKey: null
                            },
                            pinch: { enabled: true },
                            mode: 'xy'
                        },
                        limits: {
                            x: { min: 'original', max: 'original' },
                            y: { min: 'original', max: 'original' }
                        }
                    }
                },
                onClick: handleBubbleClick,
                onHover: handleBubbleHover
            },
            plugins: [
                bubbleYearWatermarkPlugin,
                bubbleCrosshairPlugin,
                bubbleTooltipPlugin
            ]
        });
        
        // ============================================
        // BUBBLE CHART VARIABLE CHANGE & UPDATE
        // ============================================
        
        /**
         * Handle variable selection change for bubble chart axes
         */
        function onBubbleVariableChange() {
            const xSelect = document.getElementById('bubble-x-select');
            const ySelect = document.getElementById('bubble-y-select');
            const sizeSelect = document.getElementById('bubble-size-select');
            
            if (xSelect?.value) bubbleXVar = xSelect.value;
            if (ySelect?.value) bubbleYVar = ySelect.value;
            if (sizeSelect?.value) bubbleSizeVar = sizeSelect.value;
            
            console.log('Bubble variables updated:', { x: bubbleXVar, y: bubbleYVar, size: bubbleSizeVar });
            
            bubbleTrails = {};
            clickedBubbleRegions = [];
            
            updateBubbleChart();
        }
        
        /**
         * Main function to update bubble chart visualization
         */
        function updateBubbleChart() {
            if (!currentYearlyData || !currentClustering) {
                console.log('Missing data for bubble chart');
                clearBubbleChart();
                return;
            }
            
            if (selectedRegionNames.length === 0) {
                console.log('No regions selected');
                clearBubbleChart();
                return;
            }
            
            const sizeScale = globalScales[bubbleSizeVar];
            if (!sizeScale) {
                console.log('No scale for size variable:', bubbleSizeVar);
                clearBubbleChart();
                return;
            }
            
            console.log(`Updating bubble chart: ${selectedRegionNames.length} regions`);
            
            const isTemporalMode = document.getElementById('temporal-toggle')?.checked || false;
            const datasets = [];
            
            selectedRegionNames.forEach(region => {
                const regionData = getRegionBubbleData(region);
                if (!regionData) {
                    console.warn(`No data for region: ${region}`);
                    return;
                }
                
                const { x: xVal, y: yVal, size: sizeVal } = regionData;
                
                const regionIdx = currentClustering.regions.indexOf(region);
                const clusterId = regionIdx >= 0 ? currentClustering.clusters[regionIdx] : 0;
                
                const fillColor = getBubbleColor(sizeVal);
                const isClicked = clickedBubbleRegions.includes(region);
                const opacity = (clickedBubbleRegions.length === 0 || isClicked) ? 1.0 : 0.3;
                const radius = calculateBubbleRadius(sizeVal);
                
                datasets.push({
                    label: region,
                    data: [{
                        x: xVal,
                        y: yVal,
                        r: radius
                    }],
                    backgroundColor: hexToRgba(fillColor, opacity),
                    borderColor: fillColor,
                    borderWidth: isClicked ? 4 : 3,
                    hoverBorderWidth: 5,
                    hoverBorderColor: '#2c3e50',
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    regionName: region,
                    clip: false
                });
                
                if (isTemporalMode && isClicked && bubbleTrails[region]?.length > 0) {
                    const trail = bubbleTrails[region];
                    
                    const trailPoints = trail.map(point => ({
                        x: point.x,
                        y: point.y,
                        r: calculateBubbleRadius(point.size) * 0.6
                    }));
                    
                    datasets.push({
                        label: `${region} Trail Line`,
                        data: trailPoints,
                        backgroundColor: 'transparent',
                        borderColor: hexToRgba(fillColor, 0.5),
                        borderWidth: 2,
                        pointRadius: 0,
                        showLine: true,
                        fill: false,
                        tension: 0.3,
                        borderDash: [8, 4],
                        clip: false
                    });
                    
                    datasets.push({
                        label: `${region} Trail Points`,
                        data: trailPoints,
                        backgroundColor: hexToRgba(fillColor, 0.3),
                        borderColor: hexToRgba(fillColor, 0.6),
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        showLine: false,
                        clip: false
                    });
                }
            });
            
            bubbleChart.data.datasets = datasets;
            
            updateBubbleAxisLabels();
            
            bubbleChart.update('none');
            
            console.log(`Bubble chart updated with ${datasets.length} datasets`);
        }
        
        /**
         * Update bubble chart axis labels
         */
        function updateBubbleAxisLabels() {
            const xLabel = indicatorNames[bubbleXVar] || bubbleXVar;
            const yLabel = indicatorNames[bubbleYVar] || bubbleYVar;
            const sizeLabel = indicatorNames[bubbleSizeVar] || bubbleSizeVar;
            
            if (!bubbleChart.options.scales.x.title) {
                bubbleChart.options.scales.x.title = { display: true };
            }
            if (!bubbleChart.options.scales.y.title) {
                bubbleChart.options.scales.y.title = { display: true };
            }
            
            bubbleChart.options.scales.x.title.text = xLabel;
            bubbleChart.options.scales.x.title.display = true;
            bubbleChart.options.scales.y.title.text = `${yLabel} (size: ${sizeLabel})`;
            bubbleChart.options.scales.y.title.display = true;
        }
        
        /**
         * Clear bubble chart
         */
        function clearBubbleChart() {
            bubbleChart.data.datasets = [];
            bubbleHoverState.active = false;
            bubbleChart.update('none');
        }

        // ============================================
        // SERVER & DATA LOADING
        // ============================================

        // Fetch clustering data from server
        async function loadClusteringData() {
            const method = 'pca';  // Fixed to PCA
            const clustering = 'kmeans';  // Fixed to K-means
            const isTemporalMode = document.getElementById('temporal-toggle').checked;
            const kMode = document.getElementById('k-mode-select').value;
            const isManualK = kMode !== 'auto';
            const manualK = parseInt(kMode);
            
            showLoading(true);
            
            try {
                if (isTemporalMode) {
                    if (isManualK) {
                        // Manual K + Temporal: load each year with manual K
                        const df = await fetch(`${SERVER_BASE}/yearly_data?year=2022`);
                        const tempData = await df.json();
                        
                        // Get all years from dataset
                        const years = [];
                        for (let year = 2002; year <= 2050; year++) {
                            years.push(year);
                        }
                        
                        // Load clustering for each year with manual K
                        const timeseries = [];
                        for (const year of years) {
                            const response = await fetch(`${SERVER_BASE}/clustering_manual?year=${year}&method=${method}&clustering=${clustering}&k=${manualK}`);
                            const data = await response.json();
                            if (data.status === 'success') {
                                timeseries.push(data);
                            }
                        }
                        
                        if (timeseries.length > 0) {
                            timeseriesData = timeseries;
                            setupTimeline();
                            updateClusterChart(timeseriesData[0]);
                            loadYearlyData(timeseriesData[0].year);
                        } else {
                            alert('Error loading manual timeseries');
                        }
                    } else {
                        // Auto K + Temporal: use precomputed
                        const response = await fetch(`${SERVER_BASE}/clustering_timeseries?method=${method}&clustering=${clustering}`);
                        const data = await response.json();
                        
                        if (data.status === 'success') {
                            timeseriesData = data.timeseries;
                            setupTimeline();
                            updateClusterChart(timeseriesData[0]);
                            loadYearlyData(timeseriesData[0].year);
                        } else {
                            alert('Error loading timeseries: ' + data.message);
                        }
                    }
                } else {
                    // Non-temporal mode
                    if (isManualK) {
                        // Manual K: compute on-the-fly
                        const response = await fetch(`${SERVER_BASE}/clustering_manual?year=overall&method=${method}&clustering=${clustering}&k=${manualK}`);
                        const data = await response.json();
                        
                        if (data.status === 'success') {
                            updateClusterChart(data);
                            loadYearlyData(2022);
                        } else {
                            alert('Error loading manual clustering: ' + data.message);
                        }
                    } else {
                        // Auto K: use precomputed
                        const response = await fetch(`${SERVER_BASE}/clustering?year=overall&method=${method}&clustering=${clustering}`);
                        const data = await response.json();
                        
                        if (data.status === 'success') {
                            updateClusterChart(data);
                            loadYearlyData(2022);
                        } else {
                            alert('Error loading clustering: ' + data.message);
                        }
                    }
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to load clustering data. Make sure the server is running.');
            } finally {
                showLoading(false);
            }
        }

        async function loadYearlyData(year) {
            try {
                console.log('Loading yearly data for year:', year);
                const response = await fetch(`${SERVER_BASE}/yearly_data?year=${year}`);
                const data = await response.json();
                
                if (data.status === 'success') {
                    currentYearlyData = data.data;
                    console.log('Yearly data loaded:', currentYearlyData.length, 'rows');
                    console.log('Sample data:', currentYearlyData.slice(0, 3));
                    
                    // Don't automatically initialize all regions as selected
                    // User should manually select regions they want to analyze
                    
                    // Build indicator names map
                    indicatorNames = {};
                    currentYearlyData.forEach(row => {
                        if (row.indicator && row.data_type && !indicatorNames[row.data_type]) {
                            // Extract name before "(" if present
                            const fullName = row.indicator;
                            const nameBeforeParen = fullName.split('(')[0].trim();
                            indicatorNames[row.data_type] = nameBeforeParen;
                        }
                    });
                    console.log('Indicator names mapped:', Object.keys(indicatorNames).length);
                    
                    // Update map variable dropdown
                    populateVariableDropdown();
                    
                    // Calculate global scales
                    calculateGlobalScales();
                    
                    // Update bubble trails in temporal mode
                    updateBubbleTrails(year);
                    
                    updateLinkedViews();
                } else {
                    console.error('Error loading yearly data:', data.message);
                }
            } catch (error) {
                console.error('Error fetching yearly data:', error);
            }
        }
        
        /**
         * Update bubble trails for temporal animation
         */
        function updateBubbleTrails(year) {
            const isTemporalMode = document.getElementById('temporal-toggle')?.checked;
            if (!isTemporalMode || !currentYearlyData) return;
            
            clickedBubbleRegions.forEach(clickedRegion => {
                if (!bubbleTrails[clickedRegion]) {
                    bubbleTrails[clickedRegion] = [];
                }
                
                const regionData = getRegionBubbleData(clickedRegion);
                if (!regionData) return;
                
                bubbleTrails[clickedRegion].push({
                    x: regionData.x,
                    y: regionData.y,
                    size: regionData.size,
                    year: year
                });
            });
        }

        function updateClusterChart(data) {
            currentClustering = data;
            
            // Group points by cluster
            const clusterGroups = {};
            for (let i = 0; i < data.regions.length; i++) {
                const clusterId = data.clusters[i];
                if (!clusterGroups[clusterId]) {
                    clusterGroups[clusterId] = {
                        points: [],
                        regions: []
                    };
                }
                clusterGroups[clusterId].points.push(data.points[i]);
                clusterGroups[clusterId].regions.push(data.regions[i]);
            }
            
            // Create datasets for each cluster
            const datasets = [];
            Object.keys(clusterGroups).sort((a, b) => parseInt(a) - parseInt(b)).forEach((clusterId, idx) => {
                const group = clusterGroups[clusterId];
                
                // Create arrays for styling (radius and border)
                const pointRadii = group.regions.map(region => 
                    selectedRegionNames.includes(region) ? 8 : 5
                );
                const pointBorderWidths = group.regions.map(region => 
                    selectedRegionNames.includes(region) ? 3 : 0
                );
                
                datasets.push({
                    label: `Cluster ${parseInt(clusterId) + 1}`,
                    data: group.points.map(p => ({ x: p[0], y: p[1] })),
                    backgroundColor: clusterColors[idx % clusterColors.length],
                    pointRadius: pointRadii,
                    pointBorderWidth: pointBorderWidths,
                    pointBorderColor: '#000',
                    pointHoverRadius: 7,
                    pointHoverBorderWidth: 2,
                    regionNames: group.regions
                });
            });
            
            clusterChart.data.datasets = datasets;
            clusterChart.update('none');
            
            // Update K display
            const kDisplay = document.getElementById('k-display');
            const kMode = document.getElementById('k-mode-select').value;
            if (kMode === 'auto') {
                kDisplay.textContent = `(K=${data.k_optimal} auto)`;
            } else {
                kDisplay.textContent = `(K=${data.k_optimal} manual)`;
            }
            
            // Update map
            updateMap(data);
            
            // Store current dataset for brush selection
            currentDataSet = data.regions.map((region, idx) => ({
                name: region,
                cluster: data.clusters[idx],
                point: data.points[idx]
            }));
        }

        function updateSelectionHighlight() {
            if (!currentClustering) return;
            
            // Update point styles based on selection
            clusterChart.data.datasets.forEach(dataset => {
                const pointRadii = [];
                const pointBorderWidths = [];
                
                dataset.regionNames.forEach(region => {
                    const isSelected = selectedRegionNames.includes(region);
                    pointRadii.push(isSelected ? 8 : 5);
                    pointBorderWidths.push(isSelected ? 3 : 0);
                });
                
                dataset.pointRadius = pointRadii;
                dataset.pointBorderWidth = pointBorderWidths;
            });
            
            clusterChart.update('none');
            
            // Update map styles
            updateMapStyles();
            
            // Update linked views
            updateLinkedViews();
        }

        function updateMap(data) {
            if (!geoJsonLayer) return;
            
            console.log('Updating map with clustering data');
            updateMapStyles();
        }
        
        function updateMapStyles() {
            if (!geoJsonLayer || !currentClustering) return;
            
            // Remove existing selection layers if any
            if (window.selectionLayer) {
                map.removeLayer(window.selectionLayer);
            }
            if (window.selectionLayerOuter) {
                map.removeLayer(window.selectionLayerOuter);
            }
            
            // Create features for selected regions with black border
            const selectedFeatures = [];
            
            geoJsonLayer.eachLayer(layer => {
                const regionName = getRegionNameFromFeature(layer.feature);
                const regionIdx = currentClustering.regions.indexOf(regionName);
                
                if (regionIdx >= 0) {
                    const clusterId = currentClustering.clusters[regionIdx];
                    const clusterColor = clusterColors[clusterId % clusterColors.length];
                    
                    let fillColor = 'transparent';
                    let fillOpacity = 0;
                    
                    // If a variable is selected, color by variable value
                    if (selectedVariable && selectedVariable !== 'none' && currentYearlyData) {
                        const value = getRegionVariableValue(regionName, selectedVariable);
                        if (value !== null && globalScales[selectedVariable]) {
                            const scale = globalScales[selectedVariable];
                            const range = scale.max - scale.min;
                            const normalized = range > 0 ? (value - scale.min) / range : 0.5;
                            fillColor = getHeatmapColor(normalized);
                            fillOpacity = 0.7;
                        }
                    }
                    
                    // Check if region is selected
                    const isSelected = selectedRegionNames.includes(regionName);
                    
                    // Base style with cluster color border
                    layer.setStyle({
                        fillColor: fillColor,
                        fillOpacity: fillOpacity,
                        weight: 3,
                        opacity: 1,
                        color: clusterColor
                    });
                    
                    // If selected, add to selection features for black inner border
                    if (isSelected) {
                        selectedFeatures.push(layer.feature);
                    }
                }
            });
            
            // Create enhanced double border for selected regions (white + black)
            if (selectedFeatures.length > 0) {
                // Outer white border for contrast
                window.selectionLayerOuter = L.geoJSON({
                    type: 'FeatureCollection',
                    features: selectedFeatures
                }, {
                    style: {
                        fillColor: 'transparent',
                        fillOpacity: 0,
                        weight: 6,
                        opacity: 1,
                        color: '#ffffff',
                        interactive: false
                    },
                    pane: 'overlayPane'
                }).addTo(map);
                
                // Inner black border
                window.selectionLayer = L.geoJSON({
                    type: 'FeatureCollection',
                    features: selectedFeatures
                }, {
                    style: {
                        fillColor: 'transparent',
                        fillOpacity: 0,
                        weight: 3,
                        opacity: 1,
                        color: '#000000',
                        interactive: false
                    },
                    pane: 'overlayPane'
                }).addTo(map);
            }
        }

        // Temporal animation functions
        function toggleTemporal() {
            const isEnabled = document.getElementById('temporal-toggle').checked;
            const controls = document.getElementById('temporal-controls');
            
            // Clear trails when switching modes
            bubbleTrails = {};
            clickedBubbleRegions = [];
            
            if (isEnabled) {
                controls.classList.add('active');
                loadClusteringData();
            } else {
                controls.classList.remove('active');
                pauseAnimation();
                loadClusteringData();
            }
        }

        function setupTimeline() {
            if (!timeseriesData || timeseriesData.length === 0) return;
            
            const slider = document.getElementById('timeline-slider');
            slider.max = timeseriesData.length - 1;
            slider.value = 0;
            currentTimeIndex = 0;
            
            updateYearDisplay();
        }

        function interpolatePoints(data1, data2, t) {
            // Interpolate only positions, keep original clusters
            return {
                regions: data1.regions,
                clusters: data1.clusters, // Keep original cluster assignments
                k_optimal: data1.k_optimal,
                year: data1.year + (data2.year - data1.year) * t,
                points: data1.points.map((point, idx) => {
                    const point2 = data2.points[idx];
                    return [
                        point[0] + (point2[0] - point[0]) * t,
                        point[1] + (point2[1] - point[1]) * t
                    ];
                }),
                centroids: data1.centroids
            };
        }

        function interpolateColors(data1, data2, points, t) {
            // Interpolate between cluster assignments (color transition)
            // For simplicity, just switch at t > 0.5
            return {
                regions: data1.regions,
                clusters: t > 0.5 ? data2.clusters : data1.clusters,
                k_optimal: data2.k_optimal,
                year: data2.year,
                points: points,
                centroids: data2.centroids
            };
        }

        function playAnimation() {
            if (!timeseriesData || isAnimationPlaying) return;
            
            // Clear trails when starting animation
            bubbleTrails = {};
            
            isAnimationPlaying = true;
            const baseSpeed = parseInt(document.getElementById('speed-select').value);
            
            // Animation phases timing
            const movementDuration = baseSpeed * 0.4;  // 40% for movement
            const colorDuration = baseSpeed * 0.2;      // 20% for color change
            const pauseDuration = baseSpeed * 0.4;      // 40% for pause
            
            // Dynamic frame rate based on speed
            const frameRate = baseSpeed < 1000 ? 30 : 50; // Faster frame rate for very fast speeds
            
            // Calculate number of steps based on duration and frame rate
            const movementSteps = Math.max(10, Math.floor(movementDuration / frameRate));
            const colorSteps = Math.max(5, Math.floor(colorDuration / frameRate));
            const pauseSteps = Math.floor(pauseDuration / frameRate);
            
            let currentPhase = 'movement'; // 'movement', 'color', 'pause'
            let stepCounter = 0;
            let finalPoints = null;
            
            animationInterval = setInterval(() => {
                const nextIndex = (currentTimeIndex + 1) % timeseriesData.length;
                
                if (currentPhase === 'movement') {
                    const progress = Math.min(stepCounter / movementSteps, 1);
                    // Smooth easing function
                    const easedProgress = progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                    
                    const interpolatedData = interpolatePoints(
                        timeseriesData[currentTimeIndex],
                        timeseriesData[nextIndex],
                        easedProgress
                    );
                    updateClusterChart(interpolatedData);
                    
                    // Update table during animation (but not too frequently)
                    if (stepCounter % 5 === 0) {
                        updateTopKTable();
                    }
                    
                    if (progress >= 1) {
                        finalPoints = interpolatedData.points;
                        currentPhase = 'color';
                        stepCounter = 0;
                    } else {
                        stepCounter++;
                    }
                    
                } else if (currentPhase === 'color') {
                    const progress = Math.min(stepCounter / colorSteps, 1);
                    
                    const colorData = interpolateColors(
                        timeseriesData[currentTimeIndex],
                        timeseriesData[nextIndex],
                        finalPoints,
                        progress
                    );
                    updateClusterChart(colorData);
                    
                    if (progress >= 1) {
                        currentPhase = 'pause';
                        stepCounter = 0;
                        currentTimeIndex = nextIndex;
                        document.getElementById('timeline-slider').value = currentTimeIndex;
                        updateYearDisplay();
                        // Load yearly data for the new year to update table
                        loadYearlyData(timeseriesData[currentTimeIndex].year);
                    } else {
                        stepCounter++;
                    }
                    
                } else if (currentPhase === 'pause') {
                    // Just wait
                    stepCounter++;
                    
                    if (stepCounter >= pauseSteps) {
                        currentPhase = 'movement';
                        stepCounter = 0;
                    }
                }
                
            }, frameRate);
        }

        function pauseAnimation() {
            isAnimationPlaying = false;
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        }

        function resetAnimation() {
            pauseAnimation();
            currentTimeIndex = 0;
            bubbleTrails = {}; // Clear trails
            clickedBubbleRegions = []; // Clear clicked regions
            if (timeseriesData && timeseriesData.length > 0) {
                updateClusterChart(timeseriesData[0]);
                document.getElementById('timeline-slider').value = 0;
                updateYearDisplay();
            }
        }

        function onTimelineChange() {
            if (!timeseriesData) return;
            
            pauseAnimation();
            currentTimeIndex = parseInt(document.getElementById('timeline-slider').value);
            updateClusterChart(timeseriesData[currentTimeIndex]);
            loadYearlyData(timeseriesData[currentTimeIndex].year);
            updateYearDisplay();
        }

        function updateYearDisplay() {
            if (!timeseriesData || currentTimeIndex >= timeseriesData.length) return;
            document.getElementById('year-display').textContent = timeseriesData[currentTimeIndex].year;
        }

        function showLoading(show) {
            const overlay = document.getElementById('cluster-loading');
            if (show) {
                overlay.classList.add('active');
            } else {
                overlay.classList.remove('active');
            }
        }

        // Brush selection for cluster chart
        const clusterCanvas = document.getElementById('clusterChart');
        
        clusterCanvas.addEventListener('mousedown', (e) => {
            if (isAnimationPlaying) return; // Disable during animation
            
            const rect = clusterCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const chartArea = clusterChart.chartArea;
            if (x >= chartArea.left && x <= chartArea.right && 
                y >= chartArea.top && y <= chartArea.bottom) {
                isDrawing = true;
                brushStart = { x, y };
                brushEnd = { x, y };
                hasMoved = false;
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            
            const rect = clusterCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            brushEnd = { x, y };
            
            // Check if moved beyond threshold (5 pixels)
            const dx = Math.abs(x - brushStart.x);
            const dy = Math.abs(y - brushStart.y);
            if (dx > 5 || dy > 5) {
                hasMoved = true;
            }
            
            clusterChart.update();
        });
        
        document.addEventListener('mouseup', () => {
            if (isDrawing) {
                isDrawing = false;
                
                if (hasMoved) {
                    // Drag selection - select all points in rectangle
                    updateBrushSelection();
                } else {
                    // Single click - select nearest point
                    selectSinglePoint();
                }
            }
        });
        
        clusterCanvas.addEventListener('dblclick', () => {
            brushStart = null;
            brushEnd = null;
            selectedRegionNames = [];
            updateSelectionHighlight();
            updateLinkedViews();
        });

        function selectSinglePoint() {
            if (!brushStart || !currentClustering) return;
            
            const xScale = clusterChart.scales.x;
            const yScale = clusterChart.scales.y;
            
            const clickX = xScale.getValueForPixel(brushStart.x);
            const clickY = yScale.getValueForPixel(brushStart.y);
            
            // Find nearest point
            let minDistance = Infinity;
            let nearestIndex = -1;
            
            for (let i = 0; i < currentClustering.points.length; i++) {
                const [px, py] = currentClustering.points[i];
                const distance = Math.sqrt(Math.pow(px - clickX, 2) + Math.pow(py - clickY, 2));
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestIndex = i;
                }
            }
            
            // Select the nearest point if within reasonable distance
            // (in data units, adjust threshold as needed)
            if (nearestIndex >= 0 && minDistance < 0.5) {
                const regionName = currentClustering.regions[nearestIndex];
                
                // Toggle point in/out of selection
                const index = selectedRegionNames.indexOf(regionName);
                if (index >= 0) {
                    // Already selected, remove it
                    selectedRegionNames.splice(index, 1);
                    console.log('Deselected region (click):', regionName);
                } else {
                    // Not selected, add it
                    selectedRegionNames.push(regionName);
                    console.log('Selected region (click):', regionName);
                }
            } else {
                // Click was too far from any point - do nothing
                console.log('No point near click');
            }
            
            // Clear brush rectangle
            brushStart = null;
            brushEnd = null;
            
            // Update visual highlighting
            updateSelectionHighlight();
            
            // Update linked views after single point selection
            updateLinkedViews();
        }

        function updateBrushSelection() {
            if (!brushStart || !brushEnd || !currentClustering) return;
            
            const xScale = clusterChart.scales.x;
            const yScale = clusterChart.scales.y;
            
            const x1 = Math.min(brushStart.x, brushEnd.x);
            const x2 = Math.max(brushStart.x, brushEnd.x);
            const y1 = Math.min(brushStart.y, brushEnd.y);
            const y2 = Math.max(brushStart.y, brushEnd.y);
            
            const dataX1 = xScale.getValueForPixel(x1);
            const dataX2 = xScale.getValueForPixel(x2);
            const dataY1 = yScale.getValueForPixel(y2);
            const dataY2 = yScale.getValueForPixel(y1);
            
            const brushedRegions = [];
            for (let i = 0; i < currentClustering.points.length; i++) {
                const [px, py] = currentClustering.points[i];
                if (px >= dataX1 && px <= dataX2 && py >= dataY1 && py <= dataY2) {
                    brushedRegions.push(currentClustering.regions[i]);
                }
            }
            
            // Toggle brushed regions in/out of selection
            brushedRegions.forEach(region => {
                const index = selectedRegionNames.indexOf(region);
                if (index >= 0) {
                    // Already selected, remove it
                    selectedRegionNames.splice(index, 1);
                } else {
                    // Not selected, add it
                    selectedRegionNames.push(region);
                }
            });
            
            console.log('Toggled regions (brush):', brushedRegions);
            console.log('Current selection:', selectedRegionNames);
            
            // Clear brush rectangle
            brushStart = null;
            brushEnd = null;
            
            // Update visual highlighting
            updateSelectionHighlight();
            
            // Update linked views after brush selection
            updateLinkedViews();
        }

        function updateTopKValue() {
            const slider = document.getElementById('k-slider');
            const display = document.getElementById('k-value-display');
            
            topKValue = parseInt(slider.value);
            display.textContent = topKValue;
            
            // Update slider gradient to show filled portion
            const percentage = ((topKValue - parseInt(slider.min)) / (parseInt(slider.max) - parseInt(slider.min))) * 100;
            slider.style.background = `linear-gradient(to right, #3498db 0%, #3498db ${percentage}%, #ddd ${percentage}%, #ddd 100%)`;
            
            updateTopKTable();
            
            // Immediately update PCP to reflect new variable ordering
            renderPCP();
        }

        function updateLinkedViews() {
            console.log('updateLinkedViews called');
            console.log('currentYearlyData:', currentYearlyData ? currentYearlyData.length : 'null');
            console.log('currentClustering:', currentClustering ? 'exists' : 'null');
            console.log('selectedRegionNames:', selectedRegionNames);
            
            if (!currentYearlyData || !currentClustering) {
                console.log('Skipping update: missing data');
                return;
            }
            
            renderPCP();
            updateBubbleChart();
            updateTopKTable();
        }

        function renderPCP() {
            console.log('renderPCP called');
            const svg = document.getElementById('pcpSvg');
            if (!svg) {
                console.error('PCP SVG element not found');
                return;
            }
            
            if (!currentYearlyData || !currentClustering || orderedPCPVariables.length === 0) {
                console.log('Missing data for PCP');
                svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#999" font-size="12">Select regions to analyze cluster profiles</text>';
                return;
            }
            
            console.log('Rendering PCP with', orderedPCPVariables.length, 'axes for', currentClustering.k_optimal, 'clusters and', selectedRegionNames.length, 'selected regions');
            
            const width = svg.clientWidth || 800;
            const height = svg.clientHeight || 300;
            const padding = { top: 100, right: 170, bottom: 20, left: 110 }; // Extra space for last rotated label
            const plotHeight = height - padding.top - padding.bottom;
            
            // Get unique clusters
            const uniqueClusters = [...new Set(currentClustering.clusters)].sort((a, b) => a - b);
            
            // Determine which clusters contain selected regions
            const selectedClusters = new Set();
            selectedRegionNames.forEach(region => {
                const regionIdx = currentClustering.regions.indexOf(region);
                if (regionIdx >= 0) {
                    selectedClusters.add(currentClustering.clusters[regionIdx]);
                }
            });
            
            // Calculate cluster medians for each variable
            const clusterData = {}; // clusterId -> { variable -> median }
            uniqueClusters.forEach(clusterId => {
                clusterData[clusterId] = {};
            });
            
            orderedPCPVariables.forEach(varObj => {
                const variable = varObj.variable;
                const data = varObj.data;
                
                uniqueClusters.forEach(clusterId => {
                    // Get values for all regions in this cluster
                    const clusterValues = [];
                    currentClustering.regions.forEach((region, idx) => {
                        if (currentClustering.clusters[idx] === clusterId && data[region] != null) {
                            clusterValues.push(data[region]);
                        }
                    });
                    
                    // Calculate median
                    if (clusterValues.length > 0) {
                        clusterValues.sort((a, b) => a - b);
                        const mid = Math.floor(clusterValues.length / 2);
                        clusterData[clusterId][variable] = clusterValues.length % 2 === 0
                            ? (clusterValues[mid - 1] + clusterValues[mid]) / 2
                            : clusterValues[mid];
                    }
                });
            });
            
            // Extract data for selected regions
            const regionData = {};
            selectedRegionNames.forEach(region => {
                regionData[region] = {};
            });
            
            orderedPCPVariables.forEach(varObj => {
                const variable = varObj.variable;
                const data = varObj.data;
                
                selectedRegionNames.forEach(region => {
                    if (data[region] != null) {
                        regionData[region][variable] = data[region];
                    }
                });
            });
            
            console.log('Cluster data calculated:', clusterData);
            console.log('Region data extracted for', selectedRegionNames.length, 'regions');
            
            // Calculate scales for each variable (global across clusters and selected regions)
            const scales = {};
            orderedPCPVariables.forEach(varObj => {
                const variable = varObj.variable;
                const values = [];
                
                // Include cluster medians
                uniqueClusters.forEach(clusterId => {
                    if (clusterData[clusterId][variable] != null) {
                        values.push(clusterData[clusterId][variable]);
                    }
                });
                
                // Include selected region values
                selectedRegionNames.forEach(region => {
                    if (regionData[region][variable] != null) {
                        values.push(regionData[region][variable]);
                    }
                });
                
                if (values.length > 0) {
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    scales[variable] = { min, max };
                } else {
                    scales[variable] = { min: 0, max: 1 };
                }
            });
            
            const axisSpacing = (width - padding.left - padding.right) / (orderedPCPVariables.length - 1);
            
            // Build SVG
            let svgContent = '';
            
            // Draw axes and labels
            orderedPCPVariables.forEach((varObj, i) => {
                const variable = varObj.variable;
                const x = padding.left + i * axisSpacing;
                
                // Axis line
                svgContent += `<line x1="${x}" y1="${padding.top}" x2="${x}" y2="${height - padding.bottom}" class="pcp-axis" />`;
                
                // Rotated label
                const labelText = indicatorNames[variable] || variable;
                svgContent += `<text x="${x}" y="${padding.top - 10}" class="pcp-axis-label-rotated" transform="rotate(-35, ${x}, ${padding.top - 10})">${labelText}</text>`;
            });
            
            // Collect all items with their first variable values for sorting and collision detection
            const allItems = [];
            const firstVarObj = orderedPCPVariables[0];
            const firstScale = scales[firstVarObj.variable];
            
            uniqueClusters.forEach(clusterId => {
                const data = clusterData[clusterId];
                const firstValue = data[firstVarObj.variable];
                if (firstValue != null) {
                    const firstNormalized = firstScale.max === firstScale.min ? 0.5 : (firstValue - firstScale.min) / (firstScale.max - firstScale.min);
                    const idealY = padding.top + plotHeight * (1 - firstNormalized);
                    allItems.push({
                        type: 'cluster',
                        id: clusterId,
                        data: data,
                        idealY: idealY,
                        actualY: idealY
                    });
                }
            });
            
            selectedRegionNames.forEach(region => {
                const data = regionData[region];
                const firstValue = data[firstVarObj.variable];
                if (firstValue != null) {
                    const firstNormalized = firstScale.max === firstScale.min ? 0.5 : (firstValue - firstScale.min) / (firstScale.max - firstScale.min);
                    const idealY = padding.top + plotHeight * (1 - firstNormalized);
                    allItems.push({
                        type: 'region',
                        name: region,
                        data: data,
                        idealY: idealY,
                        actualY: idealY
                    });
                }
            });
            
            // Sort by ideal Y position (top to bottom)
            allItems.sort((a, b) => a.idealY - b.idealY);
            
            // Resolve overlaps: minimum spacing of 14px between labels
            const minSpacing = 14;
            for (let i = 1; i < allItems.length; i++) {
                if (allItems[i].actualY - allItems[i-1].actualY < minSpacing) {
                    allItems[i].actualY = allItems[i-1].actualY + minSpacing;
                }
            }
            
            // Draw cluster lines first (background)
            allItems.forEach(item => {
                if (item.type !== 'cluster') return;
                
                const clusterId = item.id;
                const data = item.data;
                const startY = item.actualY;
                const color = clusterColors[clusterId % clusterColors.length];
                const isSelected = selectedClusters.has(clusterId);
                const strokeWidth = isSelected ? 2.5 : 1.2;
                const opacity = isSelected ? 0.6 : 0.3;
                
                // Draw label on the left (inside SVG)
                svgContent += `<text x="5" y="${startY + 4}" text-anchor="start" fill="${color}" font-size="9px" font-weight="normal" opacity="0.7">C${clusterId + 1}</text>`;
                
                // Build path starting after label
                let pathData = `M ${40} ${startY}`;
                
                orderedPCPVariables.forEach((varObj, i) => {
                    const variable = varObj.variable;
                    const value = data[variable];
                    
                    if (value == null) return;
                    
                    const scale = scales[variable];
                    const x = padding.left + i * axisSpacing;
                    const normalized = scale.max === scale.min ? 0.5 : (value - scale.min) / (scale.max - scale.min);
                    const y = padding.top + plotHeight * (1 - normalized);
                    
                    pathData += ` L ${x} ${y}`;
                });
                
                if (pathData) {
                    svgContent += `<path d="${pathData}" class="pcp-path" stroke="${color}" stroke-width="${strokeWidth}" opacity="${opacity}" fill="none" />`;
                }
            });
            
            // Draw selected region lines on top (foreground) with thicker lines
            allItems.forEach(item => {
                if (item.type !== 'region') return;
                
                const region = item.name;
                const data = item.data;
                const startY = item.actualY;
                
                // Get region's cluster color
                const regionIdx = currentClustering.regions.indexOf(region);
                const clusterId = regionIdx >= 0 ? currentClustering.clusters[regionIdx] : 0;
                const color = clusterColors[clusterId % clusterColors.length];
                
                // Draw label on the left (inside SVG)
                svgContent += `<text x="5" y="${startY + 4}" text-anchor="start" fill="${color}" font-size="10px" font-weight="bold">${region}</text>`;
                
                // Build path starting after label
                let pathData = `M ${40} ${startY}`;
                
                orderedPCPVariables.forEach((varObj, i) => {
                    const variable = varObj.variable;
                    const value = data[variable];
                    
                    if (value == null) return;
                    
                    const scale = scales[variable];
                    const x = padding.left + i * axisSpacing;
                    const normalized = scale.max === scale.min ? 0.5 : (value - scale.min) / (scale.max - scale.min);
                    const y = padding.top + plotHeight * (1 - normalized);
                    
                    pathData += ` L ${x} ${y}`;
                });
                
                if (pathData) {
                    svgContent += `<path d="${pathData}" class="pcp-path" stroke="${color}" stroke-width="3.5" opacity="0.95" fill="none" />`;
                }
            });
            
            svg.innerHTML = svgContent;
            
            // Apply zoom and pan transformation
            applyPCPTransform();
            
            console.log('PCP updated with', uniqueClusters.length, 'clusters and', selectedRegionNames.length, 'selected regions');
        }
        
        function applyPCPTransform() {
            const svg = document.getElementById('pcpSvg');
            if (!svg) return;
            
            // Apply transform to all elements except rotated labels
            const lines = svg.querySelectorAll('line');
            const paths = svg.querySelectorAll('path');
            const texts = svg.querySelectorAll('text:not(.pcp-axis-label-rotated)');
            
            [...lines, ...paths, ...texts].forEach(el => {
                el.style.transform = `translate(${pcpPanX}px, ${pcpPanY}px) scale(${pcpZoomLevel})`;
                el.style.transformOrigin = 'center';
            });
            
            // Apply transform to rotated labels while preserving rotation
            const rotatedLabels = svg.querySelectorAll('.pcp-axis-label-rotated');
            rotatedLabels.forEach(el => {
                const originalTransform = el.getAttribute('transform');
                el.style.transform = `translate(${pcpPanX}px, ${pcpPanY}px) scale(${pcpZoomLevel})`;
                el.style.transformOrigin = 'center';
                // Keep SVG transform attribute for rotation
            });
        }
        
        function zoomPCP(factor) {
            pcpZoomLevel *= factor;
            // Limit zoom levels
            pcpZoomLevel = Math.max(0.5, Math.min(pcpZoomLevel, 3));
            applyPCPTransform();
        }
        
        function resetPCPZoom() {
            pcpZoomLevel = 1;
            pcpPanX = 0;
            pcpPanY = 0;
            applyPCPTransform();
        }
        
        // Add pan functionality to PCP
        document.addEventListener('DOMContentLoaded', () => {
            const svg = document.getElementById('pcpSvg');
            if (!svg) return;
            
            svg.addEventListener('mousedown', (e) => {
                isPanning = true;
                panStartX = e.clientX - pcpPanX;
                panStartY = e.clientY - pcpPanY;
                svg.style.cursor = 'grabbing';
            });
            
            svg.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                
                const newPanX = e.clientX - panStartX;
                const newPanY = e.clientY - panStartY;
                
                // Constrain panning to keep content inside bounds
                const svgRect = svg.getBoundingClientRect();
                const maxPan = svgRect.width * (pcpZoomLevel - 1) / 2;
                const maxPanY = svgRect.height * (pcpZoomLevel - 1) / 2;
                
                pcpPanX = Math.max(-maxPan, Math.min(maxPan, newPanX));
                pcpPanY = Math.max(-maxPanY, Math.min(maxPanY, newPanY));
                
                applyPCPTransform();
            });
            
            svg.addEventListener('mouseup', () => {
                isPanning = false;
                svg.style.cursor = 'grab';
            });
            
            svg.addEventListener('mouseleave', () => {
                isPanning = false;
                svg.style.cursor = 'grab';
            });
            
            // Wheel zoom
            svg.addEventListener('wheel', (e) => {
                e.preventDefault();
                const factor = e.deltaY < 0 ? 1.1 : 0.9;
                zoomPCP(factor);
            });
        });

        // Note: onBubbleVariableChange() and updateBubbleChart() are already defined above

        function updateTopKTable() {
            const tableHead = document.getElementById('tableHead');
            const tableBody = document.getElementById('tableBody');
            
            if (!currentYearlyData || !currentClustering || selectedRegionNames.length === 0) {
                tableHead.innerHTML = '<tr><th>Select regions to view analysis</th></tr>';
                tableBody.innerHTML = '';
                return;
            }
            
            // Get all unique clusters
            const uniqueClusters = [...new Set(currentClustering.clusters)].sort((a, b) => a - b);
            
            // Get all unique data_types (variables)
            const allVariables = [...new Set(currentYearlyData.map(row => row.data_type))];
            
            // Update slider max value based on number of variables
            const slider = document.getElementById('k-slider');
            if (slider) {
                slider.max = allVariables.length;
                // Adjust current value if it exceeds max
                if (topKValue > allVariables.length) {
                    topKValue = allVariables.length;
                    slider.value = topKValue;
                    document.getElementById('k-value-display').textContent = topKValue;
                    // Update gradient
                    const percentage = ((topKValue - parseInt(slider.min)) / (parseInt(slider.max) - parseInt(slider.min))) * 100;
                    slider.style.background = `linear-gradient(to right, #3498db 0%, #3498db ${percentage}%, #ddd ${percentage}%, #ddd 100%)`;
                }
            }
            
            // Prepare data structure: variable -> region -> value
            const variableData = {};
            allVariables.forEach(variable => {
                variableData[variable] = {};
                currentClustering.regions.forEach(region => {
                    variableData[variable][region] = null;
                });
            });
            
            // Fill data from currentYearlyData
            currentYearlyData.forEach(row => {
                if (variableData[row.data_type] && variableData[row.data_type][row.region] !== undefined) {
                    variableData[row.data_type][row.region] = row.value;
                }
            });
            
            // Calculate gap normalized for each variable
            const variableGaps = [];
            
            allVariables.forEach(variable => {
                const selectedValues = [];
                const nonSelectedValues = [];
                
                currentClustering.regions.forEach(region => {
                    const value = variableData[variable][region];
                    if (value !== null && value !== undefined) {
                        if (selectedRegionNames.includes(region)) {
                            selectedValues.push(value);
                        } else {
                            nonSelectedValues.push(value);
                        }
                    }
                });
                
                if (selectedValues.length > 0 && nonSelectedValues.length > 0) {
                    // Calculate means
                    const meanSelected = selectedValues.reduce((a, b) => a + b, 0) / selectedValues.length;
                    const meanNonSelected = nonSelectedValues.reduce((a, b) => a + b, 0) / nonSelectedValues.length;
                    
                    // Calculate standard deviation of all values
                    const allValues = [...selectedValues, ...nonSelectedValues];
                    const meanAll = allValues.reduce((a, b) => a + b, 0) / allValues.length;
                    const variance = allValues.reduce((sum, val) => sum + Math.pow(val - meanAll, 2), 0) / allValues.length;
                    const stdDev = Math.sqrt(variance);
                    
                    // Normalized gap
                    const gap = stdDev > 0 ? Math.abs(meanSelected - meanNonSelected) / stdDev : 0;
                    
                    variableGaps.push({
                        variable: variable,
                        gap: gap,
                        data: variableData[variable]
                    });
                }
            });
            
            // Sort by gap descending and take top K
            variableGaps.sort((a, b) => b.gap - a.gap);
            const topKVariables = variableGaps.slice(0, topKValue);
            
            // Store ordered variables globally for PCP synchronization
            orderedPCPVariables = topKVariables.map(v => ({
                variable: v.variable,
                data: v.data
            }));
            
            if (topKVariables.length === 0) {
                tableHead.innerHTML = '<tr><th>No data available</th></tr>';
                tableBody.innerHTML = '';
                return;
            }
            
            // Build table header: Selected Regions | Cluster Medians
            let headerHTML = '<tr><th class="col-selected-regions">Variable</th>';
            
            // Add selected regions columns
            selectedRegionNames.forEach(region => {
                headerHTML += `<th>${region}</th>`;
            });
            
            // Add cluster median columns
            uniqueClusters.forEach(clusterId => {
                headerHTML += `<th>Cluster ${clusterId + 1} </th>`;
            });
            
            headerHTML += '</tr>';
            tableHead.innerHTML = headerHTML;
            
            // Build table body with heatmap coloring
            let bodyHTML = '';
            
            topKVariables.forEach(varObj => {
                const variable = varObj.variable;
                const data = varObj.data;
                
                // Collect values for this row to determine min/max for color scale
                const rowValues = [];
                
                // Get selected region values
                const selectedRegionValues = selectedRegionNames.map(region => data[region]);
                
                // Calculate cluster medians (only non-selected regions)
                const clusterMedians = uniqueClusters.map(clusterId => {
                    // First try with non-selected regions only
                    const clusterRegionsNonSelected = currentClustering.regions.filter((region, idx) => 
                        currentClustering.clusters[idx] === clusterId && !selectedRegionNames.includes(region)
                    );
                    
                    let clusterValues = clusterRegionsNonSelected
                        .map(region => data[region])
                        .filter(v => v !== null && v !== undefined);
                    
                    // If no non-selected regions (all cluster members are selected), use all cluster regions
                    if (clusterValues.length === 0) {
                        const allClusterRegions = currentClustering.regions.filter((region, idx) => 
                            currentClustering.clusters[idx] === clusterId
                        );
                        clusterValues = allClusterRegions
                            .map(region => data[region])
                            .filter(v => v !== null && v !== undefined);
                    }
                    
                    if (clusterValues.length === 0) return null;
                    
                    // Calculate median
                    clusterValues.sort((a, b) => a - b);
                    const mid = Math.floor(clusterValues.length / 2);
                    return clusterValues.length % 2 === 0
                        ? (clusterValues[mid - 1] + clusterValues[mid]) / 2
                        : clusterValues[mid];
                });
                
                // Collect all values for color scale
                selectedRegionValues.forEach(v => { if (v !== null && v !== undefined) rowValues.push(v); });
                clusterMedians.forEach(v => { if (v !== null && v !== undefined) rowValues.push(v); });
                
                // Calculate min/max for this row
                const minVal = Math.min(...rowValues);
                const maxVal = Math.max(...rowValues);
                const range = maxVal - minVal;
                
                // Start row
                bodyHTML += '<tr>';
                const displayName = indicatorNames[variable] || variable;
                bodyHTML += `<td class="col-selected-regions" style="text-align: left;">${displayName}</td>`;
                
                // Add selected region cells with color
                selectedRegionValues.forEach(value => {
                    if (value !== null && value !== undefined) {
                        const normalized = range > 0 ? (value - minVal) / range : 0.5;
                        const color = getHeatmapColor(normalized);
                        bodyHTML += `<td style="background-color: ${color};">${value.toFixed(2)}</td>`;
                    } else {
                        bodyHTML += `<td style="background-color: #f0f0f0;">-</td>`;
                    }
                });
                
                // Add cluster median cells with color
                clusterMedians.forEach(median => {
                    if (median !== null && median !== undefined) {
                        const normalized = range > 0 ? (median - minVal) / range : 0.5;
                        const color = getHeatmapColor(normalized);
                        bodyHTML += `<td style="background-color: ${color};">${median.toFixed(2)}</td>`;
                    } else {
                        bodyHTML += `<td style="background-color: #f0f0f0;">-</td>`;
                    }
                });
                
                bodyHTML += '</tr>';
            });
            
            tableBody.innerHTML = bodyHTML;
        }
        
        function getHeatmapColor(normalized) {
            // Color scale with 9 distinct orange colors from light to dark
            const colors = [
                '#fff5eb',
                '#fee6ce',
                '#fdd0a2',
                '#fdae6b',
                '#fd8d3c',
                '#f16913',
                '#d94801',
                '#a63603',
                '#7f2704'
            ];
            
            // Map normalized (0-1) to one of the 9 colors
            const index = Math.min(Math.floor(normalized * colors.length), colors.length - 1);
            return colors[index];
        }

        // Resize handler
        window.addEventListener('resize', () => {
            map.invalidateSize();
        });
        
        // Load Italy regions GeoJSON
        async function loadRegionsGeoJSON() {
            try {
                // Using public GeoJSON for Italian regions
                const response = await fetch('https://raw.githubusercontent.com/openpolis/geojson-italy/master/geojson/limits_IT_regions.geojson');
                regionGeoJson = await response.json();
                console.log('GeoJSON loaded:', regionGeoJson.features.length, 'regions');
                
                // Initialize GeoJSON layer with canvas renderer for better border control
                geoJsonLayer = L.geoJSON(regionGeoJson, {
                    style: defaultStyle,
                    onEachFeature: onEachFeature,
                    renderer: L.canvas()
                }).addTo(map);
                
            } catch (error) {
                console.error('Error loading GeoJSON:', error);
                alert('Failed to load map regions. Using fallback markers.');
            }
        }
        
        function defaultStyle(feature) {
            return {
                fillColor: 'transparent',
                weight: 2,
                opacity: 1,
                color: '#999',
                fillOpacity: 0.7
            };
        }
        
        function onEachFeature(feature, layer) {
            layer.on({
                mouseover: highlightFeature,
                mouseout: resetHighlight,
                click: selectRegionFromMap
            });
        }
        
        function highlightFeature(e) {
            const layer = e.target;
            const regionName = getRegionNameFromFeature(layer.feature);
            
            if (!selectedRegionNames.includes(regionName)) {
                layer.setStyle({
                    weight: 4,
                    opacity: 1
                });
            }
            
            // Show tooltip
            const props = layer.feature.properties;
            const name = getRegionNameFromFeature(layer.feature);
            let tooltipContent = `<b>${name}</b>`;
            
            if (currentClustering) {
                const regionIdx = currentClustering.regions.indexOf(name);
                if (regionIdx >= 0) {
                    const clusterId = currentClustering.clusters[regionIdx];
                    tooltipContent += `<br>Cluster: ${clusterId + 1}`;
                }
            }
            
            if (selectedVariable && selectedVariable !== 'none' && currentYearlyData) {
                const value = getRegionVariableValue(name, selectedVariable);
                if (value !== null) {
                    const displayName = indicatorNames[selectedVariable] || selectedVariable;
                    tooltipContent += `<br>${displayName}: ${value.toFixed(2)}`;
                }
            }
            
            layer.bindTooltip(tooltipContent).openTooltip();
        }
        
        function resetHighlight(e) {
            const layer = e.target;
            const regionName = getRegionNameFromFeature(layer.feature);
            
            // Don't use resetStyle - it causes gray color
            // Instead, reapply correct styles
            if (!selectedRegionNames.includes(regionName)) {
                // Find the region in clustering data and reapply its style
                if (currentClustering) {
                    const regionIdx = currentClustering.regions.indexOf(regionName);
                    if (regionIdx >= 0) {
                        const clusterId = currentClustering.clusters[regionIdx];
                        const clusterColor = clusterColors[clusterId % clusterColors.length];
                        
                        let fillColor = 'transparent';
                        let fillOpacity = 0;
                        
                        if (selectedVariable && selectedVariable !== 'none' && currentYearlyData) {
                            const value = getRegionVariableValue(regionName, selectedVariable);
                            if (value !== null && globalScales[selectedVariable]) {
                                const scale = globalScales[selectedVariable];
                                const range = scale.max - scale.min;
                                const normalized = range > 0 ? (value - scale.min) / range : 0.5;
                                fillColor = getHeatmapColor(normalized);
                                fillOpacity = 0.7;
                            }
                        }
                        
                        layer.setStyle({
                            fillColor: fillColor,
                            fillOpacity: fillOpacity,
                            weight: 3,
                            opacity: 1,
                            color: clusterColor
                        });
                    }
                }
            }
            
            layer.closeTooltip();
        }
        
        function selectRegionFromMap(e) {
            const layer = e.target;
            const regionName = getRegionNameFromFeature(layer.feature);
            
            // Toggle selection
            const index = selectedRegionNames.indexOf(regionName);
            if (index >= 0) {
                selectedRegionNames.splice(index, 1);
            } else {
                selectedRegionNames.push(regionName);
            }
            
            console.log('Selected from map:', regionName);
            
            // Update both visualizations
            updateMapStyles();
            updateSelectionHighlight();
        }
        
        function getRegionNameFromFeature(feature) {
            // GeoJSON properties may vary, try common field names
            const props = feature.properties;
            return props.reg_name || props.name || props.NOME_REG || props.NAME_1 || '';
        }
        
        function getRegionVariableValue(regionName, variable) {
            if (!currentYearlyData) return null;
            
            const row = currentYearlyData.find(r => r.region === regionName && r.data_type === variable);
            return row ? row.value : null;
        }
        
        // Calculate global scales for all variables
        async function calculateGlobalScales() {
            try {
                // We need to fetch data for all years to compute global min/max
                // For efficiency, we'll use a representative sample or compute on-demand
                // For now, let's compute from available data in memory
                
                // This is a simplified approach - in production you'd want to
                // either pre-compute this server-side or fetch all years once
                console.log('Computing global scales from current data...');
                
                if (!currentYearlyData) return;
                
                const variables = [...new Set(currentYearlyData.map(row => row.data_type))];
                
                variables.forEach(variable => {
                    const values = currentYearlyData
                        .filter(row => row.data_type === variable)
                        .map(row => row.value)
                        .filter(v => v !== null && v !== undefined);
                    
                    if (values.length > 0) {
                        globalScales[variable] = {
                            min: Math.min(...values),
                            max: Math.max(...values)
                        };
                    }
                });
                
                console.log('Global scales computed for', Object.keys(globalScales).length, 'variables');
            } catch (error) {
                console.error('Error computing global scales:', error);
            }
        }
        
        function updateMapVariable() {
            selectedVariable = document.getElementById('map-variable-select').value;
            console.log('Map variable changed to:', selectedVariable);
            updateMapStyles();
        }
        
        function populateVariableDropdown() {
            if (!currentYearlyData) return;
            
            const select = document.getElementById('map-variable-select');
            const variables = [...new Set(currentYearlyData.map(row => row.data_type))].sort();
            
            // Keep "None" option and add all variables
            const currentValue = select.value;
            select.innerHTML = '<option value="none">None</option>';
            
            variables.forEach(variable => {
                const displayName = indicatorNames[variable] || variable;
                const option = document.createElement('option');
                option.value = variable;
                option.textContent = displayName;
                select.appendChild(option);
            });
            
            // Restore previous selection if still valid
            if (currentValue && currentValue !== 'none' && variables.includes(currentValue)) {
                select.value = currentValue;
            }
            
            // Also populate bubble chart dropdowns
            populateBubbleDropdowns(variables);
        }
        
        function populateBubbleDropdowns(variables) {
            console.log('populateBubbleDropdowns called with', variables.length, 'variables');
            const xSelect = document.getElementById('bubble-x-select');
            const ySelect = document.getElementById('bubble-y-select');
            const sizeSelect = document.getElementById('bubble-size-select');
            
            console.log('Dropdown elements:', { xSelect: !!xSelect, ySelect: !!ySelect, sizeSelect: !!sizeSelect });
            
            if (!xSelect || !ySelect || !sizeSelect) {
                console.error('Dropdown elements not found!');
                return;
            }
            
            // Store current values
            const currentX = xSelect.value || bubbleXVar;
            const currentY = ySelect.value || bubbleYVar;
            const currentSize = sizeSelect.value || bubbleSizeVar;
            
            // Populate all three dropdowns
            [xSelect, ySelect, sizeSelect].forEach(select => {
                select.innerHTML = '';
                variables.forEach(variable => {
                    const displayName = indicatorNames[variable] || variable;
                    const option = document.createElement('option');
                    option.value = variable;
                    option.textContent = displayName;
                    select.appendChild(option);
                });
            });
            
            // Set default or restore previous values
            xSelect.value = variables.includes(currentX) ? currentX : (variables.includes('BIRTHRATE') ? 'BIRTHRATE' : variables[0]);
            ySelect.value = variables.includes(currentY) ? currentY : (variables.includes('LIFEEXP0T') ? 'LIFEEXP0T' : variables[0]);
            sizeSelect.value = variables.includes(currentSize) ? currentSize : (variables.includes('DEATHRATE') ? 'DEATHRATE' : variables[0]);
            
            // Update state variables
            bubbleXVar = xSelect.value;
            bubbleYVar = ySelect.value;
            bubbleSizeVar = sizeSelect.value;
        }
        
        // Initial load
        loadRegionsGeoJSON();
        loadClusteringData();
    </script>
</body>
</html>